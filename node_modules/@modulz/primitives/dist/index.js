'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('focus-options-polyfill');
var React = _interopDefault(require('react'));
var styled = _interopDefault(require('styled-components'));
var radixSystem = require('@modulz/radix-system');
var merge = _interopDefault(require('lodash.merge'));
var pick = _interopDefault(require('lodash.pick'));
var radixIcons = require('@modulz/radix-icons');
var omit = _interopDefault(require('lodash.omit'));
var ReactDOM = _interopDefault(require('react-dom'));
var reactTransitionGroup = require('react-transition-group');
var tabbable = _interopDefault(require('tabbable'));
var bodyScrollLock = require('body-scroll-lock');
var ariaHidden = require('aria-hidden');
var ReactIs = require('react-is');
var ResizeObserver = _interopDefault(require('resize-observer-polyfill'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * Get css reset for a given tag.
 * We could eventually make this available as a library.
 */
function cssResetForTag(tagName) {
    var sharedResetStyles = {
        boxSizing: 'border-box',
    };
    var resetStyles = __assign(__assign({}, sharedResetStyles), RESET_TAG_MAP[tagName]);
    return resetStyles;
}
/**
 * Top-level util to apply the right reset based on `as` prop or default tag name.
 */
function cssReset(defaultTagName) {
    return function (props) {
        var tagName = props.as || defaultTagName;
        return cssResetForTag(tagName);
    };
}
var RESET_TAG_MAP = {
    a: __assign(__assign({}, getFocusableResetStyles()), { color: 'inherit', textDecoration: 'none' }),
    blockquote: { margin: 0 },
    button: getBaseInputResetStyles(),
    code: { fontFamily: 'inherit' },
    div: {},
    h1: getHeadingResetStyles(),
    h2: getHeadingResetStyles(),
    h3: getHeadingResetStyles(),
    h4: getHeadingResetStyles(),
    h5: getHeadingResetStyles(),
    h6: getHeadingResetStyles(),
    header: {},
    hr: {
        margin: 0,
        border: 'none',
    },
    img: {},
    input: __assign(__assign({}, getBaseInputResetStyles()), { verticalAlign: 'middle', width: '100%', 
        // input range specific reset
        '&::-webkit-slider-runnable-track': { backgroundColor: 'transparent' }, '&::-moz-range-track': { backgroundColor: 'transparent' }, 
        // remove focus border in Firefox:
        // https://css-tricks.com/sliding-nightmare-understanding-range-input
        '::-moz-focus-outer': { border: 0 }, '&::-webkit-slider-thumb': { appearance: 'none', marginTop: 0 }, '&::-moz-range-thumb': { appearance: 'none', marginTop: 0 } }),
    p: { margin: 0 },
    select: __assign(__assign({}, getBaseInputResetStyles()), { backgroundColor: 'transparent', borderRadius: 0 }),
    span: {},
    svg: {
        display: 'block',
        verticalAlign: 'middle',
    },
    table: {},
    thead: {},
    tfoot: {},
    tbody: {},
    tr: {},
    th: { fontWeight: 'normal', padding: 0, textAlign: 'unset' },
    td: { padding: 0 },
    textarea: getBaseInputResetStyles(),
};
function getBaseInputResetStyles() {
    return __assign(__assign({}, getFocusableResetStyles()), { appearance: 'none', backgroundColor: 'transparent', border: 'none', borderRadius: 0, color: 'inherit', fontFamily: 'inherit', fontSize: 'inherit', fontWeight: 'normal', margin: 0, padding: 0 });
}
function getHeadingResetStyles() {
    return {
        margin: 0,
        fontSize: 'inherit',
        fontWeight: 'normal',
    };
}
function getFocusableResetStyles() {
    return {
        WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
        '&:focus': { outline: 'none' },
    };
}

var systemProps = function (props) { return [radixSystem.spaceSet(props), radixSystem.sx(props)]; };
var boxSystemProps = systemProps;
var boxSystemPropNames = __spreadArrays((radixSystem.spaceSet.propNames || []), ['sx']);
var Box = React.forwardRef(function Box(props, forwardedRef) {
    return React.createElement(BoxPart, __assign({}, props, { ref: forwardedRef }));
});
Box.displayName = 'Box';
var BoxPart = styled('div').attrs({ 'data-part-id': 'box' })(
// reset styles
cssReset('div'), 
// add system props
systemProps);
BoxPart.displayName = 'BoxPart';

var VisuallyHidden = React.forwardRef(function (props, forwardedRef) { return (React.createElement(VisuallyHiddenPart, __assign({}, props, { ref: forwardedRef }))); });
VisuallyHidden.displayName = 'VisuallyHidden';
// See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
var VisuallyHiddenPart = styled('span')({
    position: 'absolute',
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: 'hidden',
    clip: 'rect(0, 0, 0, 0)',
    whiteSpace: 'nowrap',
    border: 0,
});
VisuallyHiddenPart.displayName = 'VisuallyHiddenPart';

var systemProps$1 = boxSystemProps;
function AccessibleIcon(_a) {
    var children = _a.children, label = _a.label, props = __rest(_a, ["children", "label"]);
    var child = React.Children.only(children);
    return (React.createElement(WrapperPart, __assign({}, props),
        React.cloneElement(child, {
            // accessibility
            'aria-hidden': true,
            focusable: 'false',
        }),
        React.createElement(VisuallyHidden, null, label)));
}
var WrapperPart = styled('span')(
// reset styles
cssReset('span'), 
// functional styles
{
    display: 'inline-block',
}, 
// add system support
systemProps$1);

/**
 * Extract the variant names from a style config object.
 *
 * example:
 * ```
 * const styleConfig = { base: { … }, variants: { mode: { … }, size: { … } }};
 * getVariantNamesFromStyleConfig(styleConfig) => ['mode', 'size']
 * ```
 */
function getVariantNamesFromStyleConfig(styleConfig) {
    if (!styleConfig || !styleConfig.variants) {
        return [];
    }
    return Object.keys(styleConfig.variants);
}
/**
 * Utility to infer variants based on props and variant names.
 * Given all the props, and an array of variant names, computes
 * a map of variant names to variant values.
 *
 * ie.
 * ```
 * const props = { value: 'hello', onChange: () => {}, mode: 'dark' };
 * const variantNames = ['mode', 'size'];
 * makeVariantsMap(props, variantNames) => { mode: 'dark', size: 'big' }
 * ```
 */
function makeVariantsMap(props, variantNames) {
    if (variantNames === void 0) { variantNames = []; }
    return pick(props, variantNames);
}
/**
 * Primary utility to compute the final styles of a part based on:
 * - its states
 * - the global variants.
 *
 * Given a style config and the values for each variants,
 * merges and flattens all the necessary styles.
 */
function getPartStyles(partName, styleConfig, variantsMap) {
    var _a;
    if (variantsMap === void 0) { variantsMap = {}; }
    if (styleConfig === undefined) {
        return { normal: {} };
    }
    var baseStyles = styleConfig.base, variantsConfig = styleConfig.variants;
    var partBaseStyles = (_a = baseStyles[partName]) !== null && _a !== void 0 ? _a : { normal: {} };
    if (!variantsConfig) {
        return partBaseStyles;
    }
    var partVariantsStyles = Object.entries(variantsMap).map(function (_a) {
        var variantName = _a[0], variantValue = _a[1];
        var partVariantStyles = variantsConfig[variantName][variantValue];
        return partVariantStyles ? partVariantStyles[partName] : undefined;
    });
    return merge.apply(void 0, __spreadArrays([{}, partBaseStyles], partVariantsStyles));
}

var systemProps$2 = boxSystemProps;
var Alert = React.forwardRef(function Alert(props, forwardedRef) {
    var styleConfig = props.styleConfig, alertProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var alertStyles = getPartStyles('alert', styleConfig, variantsMap);
    return React.createElement(AlertPart, __assign({}, alertProps, { ref: forwardedRef, alertStyles: alertStyles }));
});
Alert.displayName = 'Alert';
var AlertPart = styled('div').attrs({ 'data-part-id': 'alert' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b = _a.alertStyles, alertStyles = _b === void 0 ? {} : _b;
    return alertStyles.normal;
}, 
// add system support
systemProps$2);
AlertPart.displayName = 'AlertPart';

var systemProps$3 = boxSystemProps;
var Arrow = React.forwardRef(function Arrow(props, forwardedRef) {
    var styleConfig = props.styleConfig, _width = props.width, _height = props.height, arrowProps = __rest(props, ["styleConfig", "width", "height"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var arrowStyles = getPartStyles('arrow', styleConfig, variantsMap);
    var width = _width || arrowStyles.normal.width || 10;
    var height = _height || arrowStyles.normal.height || 5;
    var unitlessWidth = stripUnit(width);
    var unitlessHeight = stripUnit(height);
    return (React.createElement(ArrowPart, __assign({}, arrowProps, { ref: forwardedRef, viewBox: "0 0 " + unitlessWidth + " " + unitlessHeight, width: width, height: height, arrowStyles: arrowStyles }),
        React.createElement("polygon", { points: "0,0 " + unitlessWidth + ",0 " + unitlessWidth / 2 + "," + unitlessHeight })));
});
Arrow.displayName = 'Arrow';
var ArrowPart = styled('svg').attrs({ 'data-part-id': 'arrow' })(
// reset styles
cssReset('svg'), 
// apply style config
function (_a) {
    var _b = _a.arrowStyles, arrowStyles = _b === void 0 ? {} : _b;
    var normal = arrowStyles.normal;
    // we clone the styles and delete width/height as we've already used them
    // internally to size our arrow
    var styles = __assign({}, normal);
    delete styles.width;
    delete styles.height;
    return styles;
}, 
// add system support
systemProps$3);
ArrowPart.displayName = 'ArrowPart';
function stripUnit(value) {
    return typeof value === 'string' ? Number(value.replace(/(\d+).*/, '$1')) : value;
}

var systemProps$4 = boxSystemProps;
var AspectRatio = React.forwardRef(function AspectRatio(props, forwardedRef) {
    var _a = props.ratio, ratio = _a === void 0 ? '1:1' : _a, children = props.children, aspectRatioProps = __rest(props, ["ratio", "children"]);
    var _b = ratio.split(':'), n1 = _b[0], n2 = _b[1];
    var paddingBottom = 100 / (Number(n1) / Number(n2));
    return (React.createElement(AspectRatioPart, __assign({}, aspectRatioProps, { ref: forwardedRef, style: { paddingBottom: paddingBottom + "%" } }),
        React.createElement("div", { style: { position: 'absolute', left: 0, top: 0, width: '100%', height: '100%' } }, children)));
});
AspectRatio.displayName = 'AspectRatio';
var AspectRatioPart = styled('div').attrs({ 'data-part-id': 'aspectRatio' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    width: '100%',
}, 
// add system support
systemProps$4);
AspectRatioPart.displayName = 'AspectRatioPart';

var systemProps$5 = boxSystemProps;
var Image$1 = React.forwardRef(function Image(props, forwardedRef) {
    var styleConfig = props.styleConfig, imageProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var imageStyles = getPartStyles('image', styleConfig, variantsMap);
    return React.createElement(ImagePart, __assign({}, imageProps, { ref: forwardedRef, imageStyles: imageStyles }));
});
Image$1.displayName = 'Image';
var ImagePart = styled('img').attrs({ 'data-part-id': 'image' })(
// reset styles
cssReset('img'), 
// functional styles
{
    display: 'block',
    maxWidth: '100%',
}, 
// apply style config
function (_a) {
    var _b = _a.imageStyles, imageStyles = _b === void 0 ? {} : _b;
    return imageStyles.normal;
}, 
// add system props
systemProps$5);
ImagePart.displayName = 'ImagePart';

var systemProps$6 = boxSystemProps;
var Avatar = React.forwardRef(function Avatar(props, forwardedRef) {
    var styleConfig = props.styleConfig, childrenProp = props.children, src = props.src, alt = props.alt, avatarProps = __rest(props, ["styleConfig", "children", "src", "alt"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var avatarStyles = getPartStyles('avatar', styleConfig, variantsMap);
    var imageLoadingStatus = useImageLoadingStatus(src);
    var hasImage = Boolean(src);
    var hasWorkingImage = hasImage && imageLoadingStatus !== 'error';
    var children = null;
    if (hasWorkingImage) {
        children = (React.createElement(Image$1, { src: src, alt: alt, style: {
                width: '100%',
                height: '100%',
                // Make sure images are not distorted
                objectFit: 'cover',
                // Remove alt text (appears in some browsers when image doesn't load)
                color: 'transparent',
                // Hide the image broken icon (Chrome only)
                textIndent: 10000,
            } }));
    }
    else if (childrenProp !== undefined) {
        children = childrenProp;
    }
    else if (hasImage && alt !== undefined) {
        children = alt[0];
    }
    else {
        children = React.createElement(radixIcons.AvatarIcon, null);
    }
    return (React.createElement(AvatarPart, __assign({}, avatarProps, { ref: forwardedRef, avatarStyles: avatarStyles }), children));
});
Avatar.displayName = 'Avatar';
var AvatarPart = styled('span').attrs({ 'data-part-id': 'avatar' })(
// reset styles
cssReset('span'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    verticalAlign: 'middle',
    overflow: 'hidden',
    userSelect: 'none',
}, 
// apply style config
function (_a) {
    var _b = _a.avatarStyles, avatarStyles = _b === void 0 ? {} : _b;
    return avatarStyles.normal;
}, 
// add system support
systemProps$6);
AvatarPart.displayName = 'AvatarPart';
function useImageLoadingStatus(src) {
    var _a = React.useState('idle'), loadingStatus = _a[0], setLoadingStatus = _a[1];
    React.useEffect(function () {
        if (!src) {
            return undefined;
        }
        setLoadingStatus('loading');
        var isMounted = true;
        var image = new Image();
        image.src = src;
        image.onload = function () {
            if (!isMounted)
                return;
            setLoadingStatus('loaded');
        };
        image.onerror = function () {
            if (!isMounted)
                return;
            setLoadingStatus('error');
        };
        return function () {
            isMounted = false;
        };
    }, [src]);
    return loadingStatus;
}

var systemProps$7 = boxSystemProps;
var Badge = React.forwardRef(function Badge(props, forwardedRef) {
    var styleConfig = props.styleConfig, badgeProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var badgeStyles = getPartStyles('badge', styleConfig, variantsMap);
    return React.createElement(BadgePart, __assign({}, badgeProps, { ref: forwardedRef, badgeStyles: badgeStyles }));
});
Badge.displayName = 'Badge';
var BadgePart = styled('span').attrs({ 'data-part-id': 'badge' })(
// reset styles
cssReset('span'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
    verticalAlign: 'middle',
    lineHeight: '1',
    userSelect: 'none',
    whiteSpace: 'nowrap',
}, 
// apply style config
function (_a) {
    var _b = _a.badgeStyles, badgeStyles = _b === void 0 ? {} : _b;
    return badgeStyles.normal;
}, 
// add system support
systemProps$7);
BadgePart.displayName = 'BadgePart';

var systemProps$8 = boxSystemProps;
var Blockquote = React.forwardRef(function Blockquote(props, forwardedRef) {
    var styleConfig = props.styleConfig, blockquoteProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var blockquoteStyles = getPartStyles('blockquote', styleConfig, variantsMap);
    return React.createElement(BlockquotePart, __assign({}, blockquoteProps, { ref: forwardedRef, blockquoteStyles: blockquoteStyles }));
});
Blockquote.displayName = 'Blockquote';
var BlockquotePart = styled('blockquote').attrs({ 'data-part-id': 'blockquote' })(
// reset styles
cssReset('blockquote'), 
// apply style config
function (_a) {
    var _b = _a.blockquoteStyles, blockquoteStyles = _b === void 0 ? {} : _b;
    return blockquoteStyles.normal;
}, 
// add system support
systemProps$8);
BlockquotePart.displayName = 'BlockquotePart';

var systemProps$9 = boxSystemProps;
var Button = React.forwardRef(function Button(props, forwardedRef) {
    var styleConfig = props.styleConfig, buttonProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var buttonStyles = getPartStyles('button', styleConfig, variantsMap);
    return React.createElement(ButtonPart, __assign({}, buttonProps, { ref: forwardedRef, buttonStyles: buttonStyles }));
});
Button.displayName = 'Button';
var ButtonPart = styled('button').attrs({ 'data-part-id': 'button' })(
// reset styles
cssReset('button'), 
// functional styles
{
    lineHeight: '1',
    userSelect: 'none',
    '&:disabled': { pointerEvents: 'none' },
}, 
// apply style config
function (_a) {
    var _b = _a.buttonStyles, buttonStyles = _b === void 0 ? {} : _b;
    var normal = buttonStyles.normal, hover = buttonStyles.hover, focus = buttonStyles.focus, active = buttonStyles.active, disabled = buttonStyles.disabled;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active, '&:disabled': disabled });
}, 
// add system support
systemProps$9);
ButtonPart.displayName = 'ButtonPart';

var systemProps$a = boxSystemProps;
var Card = React.forwardRef(function Card(props, forwardedRef) {
    var styleConfig = props.styleConfig, cardProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var cardStyles = getPartStyles('card', styleConfig, variantsMap);
    return React.createElement(CardPart, __assign({}, cardProps, { ref: forwardedRef, cardStyles: cardStyles }));
});
Card.displayName = 'Card';
var CardPart = styled('div').attrs({ 'data-part-id': 'card' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b = _a.cardStyles, cardStyles = _b === void 0 ? {} : _b;
    return cardStyles.normal;
}, 
// add system support
systemProps$a);
CardPart.displayName = 'CardPart';

var CardLink = React.forwardRef(function CardLink(props, forwardedRef) {
    var styleConfig = props.styleConfig, cardProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var cardLinkStyles = getPartStyles('card', styleConfig, variantsMap);
    return React.createElement(CardLinkPart, __assign({}, cardProps, { ref: forwardedRef, cardLinkStyles: cardLinkStyles }));
});
CardLink.displayName = 'CardLink';
var CardLinkPart = styled('a').attrs({ 'data-part-id': 'cardLink' })(
// reset styles
cssReset('a'), 
// functional styles
{
    display: 'block',
}, 
// apply style config
function (_a) {
    var _b = _a.cardLinkStyles, cardLinkStyles = _b === void 0 ? {} : _b;
    var normal = cardLinkStyles.normal, hover = cardLinkStyles.hover, focus = cardLinkStyles.focus, active = cardLinkStyles.active;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active });
}, 
// add system support
systemProps$a);
CardLinkPart.displayName = 'CardLinkPart';

var _a;
var systemProps$b = boxSystemProps;
var systemPropNames = boxSystemPropNames;
var Checkbox = React.forwardRef(function Checkbox(props, forwardedRef) {
    var className = props.className, style = props.style, styleConfig = props.styleConfig;
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var checkboxStyles = getPartStyles('checkbox', styleConfig, variantsMap);
    var iconStyles = getPartStyles('icon', styleConfig, variantsMap);
    var systemProps = pick(props, systemPropNames);
    var inputProps = omit(props, systemPropNames);
    return (React.createElement(Wrapper, __assign({ className: className, style: style }, systemProps),
        React.createElement(Input, __assign({}, inputProps, { type: "checkbox", ref: forwardedRef })),
        React.createElement(CheckboxPart, { checkboxStyles: checkboxStyles },
            React.createElement(IconPart, { iconStyles: iconStyles },
                React.createElement(radixIcons.CheckIcon, { style: { display: 'block' } })))));
});
Checkbox.displayName = 'Checkbox';
var Wrapper = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-block',
    verticalAlign: 'middle',
    position: 'relative',
}, 
// add system support
systemProps$b);
var Input = styled('input')(
// reset styles
cssReset('input'), 
// functional styles
{
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    zIndex: 1,
    opacity: 0,
    '&:disabled': { pointerEvents: 'none' },
});
var CheckboxPart = styled('div').attrs({ 'data-part-id': 'checkbox' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    zIndex: 0,
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.checkboxStyles, checkboxStyles = _c === void 0 ? {} : _c;
    var normal = checkboxStyles.normal, hover = checkboxStyles.hover, focus = checkboxStyles.focus, active = checkboxStyles.active, checked = checkboxStyles.checked, disabled = checkboxStyles.disabled;
    return __assign(__assign({}, normal), (_b = {}, _b[Input + ":hover + &"] = hover, _b[Input + ":focus + &"] = focus, _b[Input + ":active + &"] = active, _b[Input + ":checked + &"] = checked, _b[Input + ":disabled + &"] = disabled, _b));
});
CheckboxPart.displayName = 'CheckboxPart';
var IconPart = styled('div').attrs({ 'data-part-id': 'icon' })(
// reset styles
cssReset('div'), (_a = {
        position: 'absolute',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        pointerEvents: 'none',
        opacity: 0
    },
    _a[Input + ":checked + " + CheckboxPart + " &"] = {
        opacity: 1,
    },
    _a), 
// apply style config
function (_a) {
    var _b = _a.iconStyles, iconStyles = _b === void 0 ? {} : _b;
    return iconStyles.normal;
});
IconPart.displayName = 'IconPart';

var systemProps$c = boxSystemProps;
var Code = React.forwardRef(function Code(props, forwardedRef) {
    var styleConfig = props.styleConfig, cardProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var codeStyles = getPartStyles('code', styleConfig, variantsMap);
    return React.createElement(CodePart, __assign({}, cardProps, { ref: forwardedRef, codeStyles: codeStyles }));
});
Code.displayName = 'Code';
var CodePart = styled('code').attrs({ 'data-part-id': 'code' })(
// reset styles
cssReset('code'), 
// apply style config
function (_a) {
    var _b = _a.codeStyles, codeStyles = _b === void 0 ? {} : _b;
    return codeStyles.normal;
}, 
// add system support
systemProps$c);
CodePart.displayName = 'CodePart';

var systemProps$d = boxSystemProps;
var Container = React.forwardRef(function Container(props, forwardedRef) {
    var styleConfig = props.styleConfig, containerProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var containerStyles = getPartStyles('container', styleConfig, variantsMap);
    return React.createElement(ContainerPart, __assign({}, containerProps, { ref: forwardedRef, containerStyles: containerStyles }));
});
Container.displayName = 'Container';
var ContainerPart = styled('div').attrs({ 'data-part-id': 'container' })(
// reset styles
cssReset('div'), 
// functional styles
{
    marginLeft: 'auto',
    marginRight: 'auto',
    flex: 1,
}, 
// apply style config
function (_a) {
    var _b = _a.containerStyles, containerStyles = _b === void 0 ? {} : _b;
    return containerStyles.normal;
}, 
// add system support
systemProps$d);
ContainerPart.displayName = 'ContainerPart';

var DebugContext = React.createContext({
    portalContainerRef: undefined,
    disableCollisionChecking: false,
    disableLock: false,
    viewportGap: undefined,
});
function DebugContextProvider(_a) {
    var children = _a.children, debugContext = __rest(_a, ["children"]);
    return React.createElement(DebugContext.Provider, { value: debugContext }, children);
}
function useDebugContext() {
    return React.useContext(DebugContext);
}

function Portal(_a) {
    var children = _a.children, containerRef = _a.containerRef;
    var debugContext = useDebugContext();
    // Lazy initialization of the host element
    // This is to make sure we don't recreate a new DOM element on each render
    var hostElement = React.useState(getHostElement)[0];
    function getHostElement() {
        if (typeof document !== 'undefined') {
            return document.createElement('radix-portal');
        }
        // bail out of ssr
        return null;
    }
    // We append the host element and remove it when necessary
    React.useEffect(function () {
        var _a;
        if (!hostElement) {
            return;
        }
        // prioritize a custom container set via our `DebugContextProvider`
        if (debugContext.portalContainerRef !== undefined) {
            (_a = debugContext.portalContainerRef.current) === null || _a === void 0 ? void 0 : _a.appendChild(hostElement);
        }
        // then prioritize a custom container via `containerRef` prop
        else if (containerRef && containerRef.current) {
            containerRef.current.appendChild(hostElement);
        }
        // default to `document.body`
        else {
            document.body.appendChild(hostElement);
        }
        return function () {
            hostElement.remove();
        };
    }, [hostElement, containerRef, debugContext.portalContainerRef]);
    if (hostElement) {
        // Render the children of `Portal` inside the host element
        return ReactDOM.createPortal(children, hostElement);
    }
    // bail out of ssr
    return null;
}

/**
 * Set a given ref to a given value
 * This utility takes care of different types of refs: callback refs and RefObject(s)
 */
function setRef(ref, value) {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref !== null && ref !== undefined) {
        ref.current = value;
    }
}
/**
 * A utility to compose multiple refs together
 * Accepts callback refs and RefObject(s)
 */
function composeRefs() {
    var refs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
    }
    return function (node) { return refs.forEach(function (ref) { return setRef(ref, node); }); };
}
/**
 * A custom hook that composes multiple refs
 * Accepts callback refs and RefObject(s)
 */
function useComposedRefs() {
    var refs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
    }
    return React.useCallback(composeRefs.apply(void 0, refs), refs);
}

// If something goes wrong, this it the maximum duration we are willing to wait until we will unmount the tree.
var MAX_TIMEOUT_BEFORE_FORCED_UNMOUNT = 5000;
var PresenceTransitionContext = React.createContext({
    isPresent: false,
    addObservedElementRef: function (ref) { },
    removeObservedElementRef: function (ref) { },
});
/**
 * This component is used to mount and unmount a react tree correctly
 * based on running transitions on certain elements.
 */
function PresenceTransition(_a) {
    var children = _a.children, isPresent = _a.isPresent;
    var transitionEndListenerCallbackRef = React.useRef(function () { });
    var observedElementRefs = React.useRef([]);
    // Observe when all our observed elements are finishing their exit transition
    useTransitionEnd({
        isObserving: !isPresent,
        observedElementRefs: observedElementRefs,
        onTransitionEnd: function () { return transitionEndListenerCallbackRef.current(); },
    });
    var addObservedElementRef = React.useCallback(function (ref) {
        observedElementRefs.current.push(ref);
    }, []);
    var removeObservedElementRef = React.useCallback(function (ref) {
        var index = observedElementRefs.current.indexOf(ref);
        if (index !== -1) {
            observedElementRefs.current.splice(index, 1);
        }
    }, []);
    return (React.createElement(reactTransitionGroup.Transition, { in: isPresent, timeout: MAX_TIMEOUT_BEFORE_FORCED_UNMOUNT, mountOnEnter: true, unmountOnExit: true, 
        // store the callback to trigger unmount in a ref
        addEndListener: function (_, done) { return (transitionEndListenerCallbackRef.current = done); } },
        React.createElement(PresenceTransitionContext.Provider, { value: { isPresent: isPresent, addObservedElementRef: addObservedElementRef, removeObservedElementRef: removeObservedElementRef } }, children)));
}
function PartTransition(_a) {
    var children = _a.children;
    var _b = React.useContext(PresenceTransitionContext), isPresent = _b.isPresent, addObservedElementRef = _b.addObservedElementRef, removeObservedElementRef = _b.removeObservedElementRef;
    var child = React.Children.only(children);
    var ref = React.useRef(null);
    // Each transition part registers its ref onto the main `TransitionPresence` component
    // so it knows which elements we should observe transitions on.
    React.useEffect(function () {
        addObservedElementRef(ref);
        return function () {
            removeObservedElementRef(ref);
        };
    }, [addObservedElementRef, removeObservedElementRef]);
    return (React.createElement(reactTransitionGroup.CSSTransition, { in: isPresent, addEndListener: function () { }, appear: true }, React.cloneElement(child, { ref: composeRefs(child.ref, ref) })));
}
/**
 * This hook is used to observe transitions and notify
 * when all transitions on a set of observed elements are complete.
 */
function useTransitionEnd(_a) {
    var isObserving = _a.isObserving, observedElementRefs = _a.observedElementRefs, onTransitionEnd = _a.onTransitionEnd;
    React.useEffect(function () {
        // We will increment a counter when a transition runs and decrement it when it ends (or gets cancelled)
        // We can then use this counter as an indication that we're done (when it comes back to 0).
        var transitionCount = 0;
        function handleTransitionRun(event) {
            // We only care about transitions on elements we observe (ie. don't count user content transitions)
            if (isEventOnObservedElement(event, observedElementRefs)) {
                transitionCount++;
                document.addEventListener('transitionend', handleTransitionEnd);
                document.addEventListener('transitioncancel', handleTransitionEnd);
            }
        }
        function handleTransitionEnd(event) {
            // We only care about transitions on elements we observe (ie. don't count user content transitions)
            if (isEventOnObservedElement(event, observedElementRefs)) {
                transitionCount--;
                // All transitions have ended
                if (transitionCount === 0) {
                    onTransitionEnd();
                }
            }
        }
        if (isObserving) {
            // we wait for a transition to be scheduled
            // we use `transitionrun` as the transition might have a delay and `transitionstart` is when it starts
            document.addEventListener('transitionrun', handleTransitionRun);
            // In case there are no transitions set at all, we want to make sure we trigger the callback as soon as possible.
            // This is because we do not want to suffer from the `timeout` fallback on transitions.
            //
            // We give it time to check if there are any transitions set (`transitionrun` events)
            // and if there are none, then we're done.
            //
            // From testing, one frame wasn't enough… so we need 2.
            var rafId1_1, rafId2_1;
            rafId1_1 = requestAnimationFrame(function () {
                rafId2_1 = requestAnimationFrame(function () {
                    if (transitionCount === 0) {
                        onTransitionEnd();
                    }
                });
            });
            return function () {
                document.removeEventListener('transitionrun', handleTransitionRun);
                document.removeEventListener('transitionend', handleTransitionEnd);
                document.removeEventListener('transitioncancel', handleTransitionEnd);
                cancelAnimationFrame(rafId1_1);
                cancelAnimationFrame(rafId2_1);
            };
        }
    }, [observedElementRefs, isObserving, onTransitionEnd]);
}
function isEventOnObservedElement(event, elementRefs) {
    var _a, _b;
    return (_b = (_a = elementRefs.current) === null || _a === void 0 ? void 0 : _a.some(function (elementRef) { return elementRef.current === event.target; })) !== null && _b !== void 0 ? _b : false;
}

var systemProps$e = boxSystemProps;
var Overlay = React.forwardRef(function Overlay(props, forwardedRef) {
    var styleConfig = props.styleConfig, overlayProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var pverlayStyles = getPartStyles('overlay', styleConfig, variantsMap);
    return (React.createElement(PartTransition, null,
        React.createElement(OverlayPart, __assign({}, overlayProps, { ref: forwardedRef, overlayStyles: pverlayStyles }))));
});
Overlay.displayName = 'Overlay';
var OverlayPart = styled('div').attrs({ 'data-part-id': 'overlay' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'fixed',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
}, 
// apply style config
function (_a) {
    var _b = _a.overlayStyles, overlayStyles = _b === void 0 ? {} : _b;
    var normal = overlayStyles.normal, enter = overlayStyles.enter, opened = overlayStyles.opened, exit = overlayStyles.exit;
    return __assign(__assign({}, normal), { '&.enter, &.appear': enter, '&.enter-active, &.appear-active': opened, '&.exit': opened, '&.exit-active': exit });
}, 
// add system support
systemProps$e);
OverlayPart.displayName = 'OverlayPart';

function arrayRemove(array, item) {
    var updatedArray = __spreadArrays(array);
    var index = updatedArray.indexOf(item);
    if (index !== -1) {
        updatedArray.splice(index, 1);
    }
    return updatedArray;
}
function arrayInsert(array, item, index) {
    return __spreadArrays(array.slice(0, index), [item], array.slice(index));
}

/**
 * Creates a new focus trap which can be programmatically activated/deactivated
 */
function createFocusTrap(initialConfig) {
    // We keep track of the config internally as we allow dynamically updating some of it through setters
    var config = __assign({}, initialConfig);
    // We keep track of some internal state
    var state = {
        isActive: false,
        isPaused: false,
        elementFocusedBeforeActivation: undefined,
        // In order to perform the focus trapping, we create (and later inject) 2 focusable marker elements.
        // One is injected just before the focus trap, and the other just after it.
        //
        // Their function is twofold:
        //
        // - when the focus escapes the focus trap, it ensures one of these will be focused with no visual feedback.
        // - they serve as markers to know which direction the user was tabbing through
        beforeFocusTrapMarker: createTrapMarkerElement('before'),
        afterFocusTrapMarker: createTrapMarkerElement('after'),
    };
    var removeEscapeListener = function () { };
    var removeOutsideClickListener = function () { };
    var stopBlockingOutsidePointerEvents = function () { };
    var stopHidingOutsideFromScreenReaders = function () { };
    var focusTrap = {
        isActive: function () { return state.isActive; },
        activate: activate,
        deactivate: deactivate,
        pause: pause,
        resume: resume,
        updateConfig: updateConfig,
    };
    return focusTrap;
    function activate() {
        if (state.isActive)
            return;
        state.isActive = true;
        state.isPaused = false;
        makeFocusable(config.container);
        attachFocusTrapMarkers();
        startHidingOutsideFromScreenReaders();
        focusTrapsManager.add(focusTrap);
        // We delay activation by a frame in case the focus trap was activated
        // via a `mousedown` event rather than `click` event.
        // This is because `focus` happens before `click` but after `mousedown`
        // so if we didn't delay, the element clicked wouldn't have time to focus.
        requestAnimationFrame(function () {
            performFocusOnActivation();
            addListeners();
        });
    }
    function deactivate(_a) {
        var _b = (_a === void 0 ? {} : _a).shouldPreventFocusControl, shouldPreventFocusControl = _b === void 0 ? false : _b;
        if (!state.isActive)
            return;
        state.isActive = false;
        state.isPaused = false;
        makeNonFocusable(config.container);
        detachFocusTrapMarkers();
        stopHidingOutsideFromScreenReaders();
        removeListeners();
        focusTrapsManager.remove(focusTrap);
        // We delay deactivation focus by a frame in case the focus trap was deactivated
        // via a `mousedown` event rather than `click` event.
        // This is because `focus` happens before `click` but after `mousedown`
        // so if we didn't delay, the element clicked (inside the trap) would gain focus
        // after the focus trap was deactivated.
        requestAnimationFrame(function () {
            if (!shouldPreventFocusControl) {
                performFocusOnDeactivation();
            }
        });
    }
    function pause() {
        if (state.isPaused || !state.isActive)
            return;
        state.isPaused = true;
        removeListeners();
    }
    function resume() {
        if (!state.isPaused || !state.isActive)
            return;
        state.isPaused = false;
        addListeners();
    }
    function updateConfig(updatedConfig) {
        function wasKeyUpdated(key) {
            return key in updatedConfig && config[key] !== updatedConfig[key];
        }
        var wasShouldBlockOutsideClickUpdated = wasKeyUpdated('shouldBlockOutsideClick');
        var wasShouldLockScrollUpdated = wasKeyUpdated('shouldLockScroll');
        // update config
        config = __assign(__assign({}, config), updatedConfig);
        // deal with dynamic changes whilst the focus trap is currently active
        if (state.isActive) {
            if (wasShouldBlockOutsideClickUpdated) {
                if (updatedConfig.shouldBlockOutsideClick) {
                    startBlockingOutsidePointerEvents();
                }
                else {
                    stopBlockingOutsidePointerEvents();
                }
            }
            if (wasShouldLockScrollUpdated) {
                if (updatedConfig.shouldLockScroll) {
                    startLockingScroll();
                }
                else {
                    stopLockingScroll();
                }
            }
        }
    }
    function performFocusOnActivation() {
        state.elementFocusedBeforeActivation = getCurrentlyFocusedElement();
        var firstTabbableElement = getFirstTabbableElement(config.container);
        var elementToFocus = config.elementToFocusWhenActivated || firstTabbableElement;
        attemptFocus(elementToFocus, ACTIVATION_FOCUS_ERROR, config.container);
    }
    function performFocusOnDeactivation() {
        var elementToFocus = config.elementToFocusWhenDeactivated || state.elementFocusedBeforeActivation;
        attemptFocus(elementToFocus, DEACTIVATION_FOCUS_ERROR);
    }
    function handleBlur(event) {
        var relatedTarget = event.relatedTarget;
        if (!config.container.contains(relatedTarget)) {
            handleFocusOutside(relatedTarget);
        }
    }
    function handleFocus(event) {
        if (isEventOutsideElement(event, config.container)) {
            handleFocusOutside(event.target);
        }
    }
    function handleFocusOutside(elementReceivingFocus) {
        // If we got here, it means the focus event was technically outside the container.
        // We do an extra check for focus within any focus trap container. This is because focus trap containers
        // are not always truly nested in the DOM (ie. when used within a Portal)
        if (elementReceivingFocus === null || elementReceivingFocus === void 0 ? void 0 : elementReceivingFocus.closest('[data-focus-trap-container=true]')) {
            // in such case we allow manually focusing into parent locks (via click)
            return;
        }
        if (elementReceivingFocus === state.beforeFocusTrapMarker) {
            var lastTabbableElement = getLastTabbableElement(config.container);
            attemptFocus(lastTabbableElement, 'Could not focus last tabbable element', config.container);
        }
        else {
            var firstTabbableElement = getFirstTabbableElement(config.container);
            attemptFocus(firstTabbableElement, 'Could not focus first tabbable element', config.container);
        }
    }
    function handleEscape(event) {
        if (config.shouldDeactivateOnEscape) {
            config.onEscape && config.onEscape(event);
        }
    }
    function handleOutsideClick(event) {
        var _a;
        // If we got here, it means the click event was technically outside the container.
        // We do an extra check for clicks within any focus trap container. This is because focus trap containers
        // are not always truly nested in the DOM (ie. when used within a Portal)
        if ((_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('[data-focus-trap-container=true]')) {
            // in such case we do not want to treat this as a click outside of the focus trap.
            return;
        }
        var shouldDeactivate = typeof config.shouldDeactivateOnOutsideClick === 'function'
            ? config.shouldDeactivateOnOutsideClick(event)
            : Boolean(config.shouldDeactivateOnOutsideClick);
        if (shouldDeactivate) {
            // when deactivating by clicking outside, prevent normal return focus behaviour
            // (to `elementFocusedBeforeActivation` or `elementToFocusOnDeactivate`)
            // ONLY IF we are NOT blocking outside clicks (clicks are allowed to go through)
            // instead let the browser do what it needs to do (ie. focus a focusable element, etc)
            var shouldPreventFocusControl = !config.shouldBlockOutsideClick;
            config.onOutsideClick && config.onOutsideClick(event, shouldPreventFocusControl);
        }
        else {
            // prevent focusing the clicked element
            event.preventDefault();
        }
    }
    function startBlockingOutsidePointerEvents() {
        // make sure we always clean up if it was already blocking
        stopBlockingOutsidePointerEvents();
        // start blocking
        stopBlockingOutsidePointerEvents = blockOutsidePointerEvents(config.container);
    }
    function startLockingScroll() {
        bodyScrollLock.disableBodyScroll(config.container, { reserveScrollBarGap: true });
    }
    function stopLockingScroll() {
        bodyScrollLock.enableBodyScroll(config.container);
    }
    function attachFocusTrapMarkers() {
        var parent = config.container.parentNode;
        if (parent === null)
            return;
        parent.insertBefore(state.beforeFocusTrapMarker, config.container);
        parent.insertBefore(state.afterFocusTrapMarker, config.container.nextSibling);
    }
    function detachFocusTrapMarkers() {
        state.beforeFocusTrapMarker.remove();
        state.afterFocusTrapMarker.remove();
    }
    function startHidingOutsideFromScreenReaders() {
        stopHidingOutsideFromScreenReaders = ariaHidden.hideOthers(config.container);
    }
    function addListeners() {
        // `focus` and `blur` events don't bubble so we need to use the capture phase
        // https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event
        document.addEventListener('blur', handleBlur, { capture: true });
        document.addEventListener('focus', handleFocus, { capture: true });
        removeEscapeListener = onEscapeKeydown(handleEscape);
        removeOutsideClickListener = onOutsidePointerDown(config.container, handleOutsideClick);
        if (config.shouldBlockOutsideClick) {
            startBlockingOutsidePointerEvents();
        }
        if (config.shouldLockScroll) {
            startLockingScroll();
        }
    }
    function removeListeners() {
        document.removeEventListener('blur', handleBlur, { capture: true });
        document.removeEventListener('focus', handleFocus, { capture: true });
        removeEscapeListener();
        removeOutsideClickListener();
        stopBlockingOutsidePointerEvents();
        stopLockingScroll();
    }
}
// NOTE: `createFocusTrap` ends here
// Below are pure functions that don't need to close over any variables from `createFocusTrap`
function createTrapMarkerElement(position) {
    var trapMarkerElement = document.createElement('div');
    trapMarkerElement.setAttribute('data-focus-trap-marker', position);
    trapMarkerElement.tabIndex = 0;
    return trapMarkerElement;
}
function makeFocusable(container) {
    container.style.outline = 'none';
    container.tabIndex = -1;
    container.setAttribute('data-focus-trap-container', 'true');
}
function makeNonFocusable(container) {
    container.style.outline = '';
    container.removeAttribute('tabIndex');
    container.removeAttribute('data-focus-trap-container');
}
function isEventOutsideElement(event, element) {
    return !element.contains(event.target);
}
function getCurrentlyFocusedElement() {
    return document.activeElement;
}
function getFirstTabbableElement(container) {
    var tabbableElements = tabbable(container, { includeContainer: false });
    return tabbableElements[0];
}
function getLastTabbableElement(container) {
    var tabbableElements = tabbable(container, { includeContainer: false });
    return tabbableElements[tabbableElements.length - 1];
}
function isHTMLElement(element) {
    return element instanceof HTMLElement;
}
function isSelectableInput(element) {
    return isHTMLElement(element) && element.tagName.toLowerCase() === 'input' && 'select' in element;
}
/**
 * Attempts focusing the given element.
 * If unsuccessful, displays an error in the console and potentially focus will fall back on a provided `fallbackElement`.
 */
function attemptFocus(element, errorMessage, fallbackElement) {
    var wasSuccessfullyFocused = focus(element);
    // only show warnings and run fallback:
    // - if we didn't have an element to focus
    //   (this is the case where nothing is tabbable so we need to fallback to container)
    // - if we have a real HTML element but focus didn't work for some reason
    if (element === undefined || (isHTMLElement(element) && !wasSuccessfullyFocused)) {
        if (Boolean(errorMessage)) {
            console.warn(errorMessage);
        }
        if (fallbackElement !== undefined) {
            console.info('Falling back to container focus');
            focus(fallbackElement);
        }
    }
}
/**
 * Moves focus to a given element (and select it if it is a selectable input)
 * Returns whether the focus was successfully moved to the given element
 */
function focus(element) {
    if (element && element.focus) {
        // NOTE: we prevent scrolling on focus because we are not preventing overflow in our `Popover`
        // If scroll isn't prevented and the popover is partially cut-off, the browser would try to
        // get the focused element to fit in view no matter what and would just bust the layout.
        element.focus({ preventScroll: true });
        if (isSelectableInput(element)) {
            element.select();
        }
    }
    return getCurrentlyFocusedElement() === element;
}
/**
 * Sets up a keydown listener which listens for the escape key.
 * Return a function to remove the listener.
 */
function onEscapeKeydown(
/** A function to be called when the escape key is pressed */
callback) {
    document.addEventListener('keydown', handleKeydown, { capture: true });
    return function () {
        document.removeEventListener('keydown', handleKeydown, { capture: true });
    };
    function handleKeydown(event) {
        if (event.key === 'Escape') {
            callback(event);
        }
    }
}
/**
 * Sets up mousedown/touchstart listeners which listens for pointer down events outside the given container.
 * Return a function to remove the listeners.
 */
function onOutsidePointerDown(
/** The container used as a reference to check if events happen outside */
container, 
/** A function to be called when a pointer down even happens outside the given container */
callback) {
    document.addEventListener('mousedown', handlePointerDown, { capture: true });
    document.addEventListener('touchstart', handlePointerDown, { capture: true });
    return function () {
        document.removeEventListener('mousedown', handlePointerDown, { capture: true });
        document.removeEventListener('touchstart', handlePointerDown, { capture: true });
    };
    function handlePointerDown(event) {
        if (isEventOutsideElement(event, container)) {
            callback(event);
        }
    }
}
/**
 * Blocks outside pointer events.
 * Returns a function to stop blocking.
 */
function blockOutsidePointerEvents(
/** The container used as a reference to check if events should be blocked (if they happen outside of it) */
container) {
    var originalBodyPointerEvents = document.body.style.pointerEvents;
    var originalContainerPointerEvents = container.style.pointerEvents;
    document.body.style.pointerEvents = 'none';
    container.style.pointerEvents = 'auto';
    var stopOutsidePointerDownListener = onOutsidePointerDown(container, function (event) {
        // NOTE: We do this to prevent focus event from happening on focusable elements
        event.preventDefault();
    });
    return function () {
        document.body.style.pointerEvents = originalBodyPointerEvents;
        container.style.pointerEvents = originalContainerPointerEvents;
        stopOutsidePointerDownListener();
    };
}
var ACTIVATION_FOCUS_ERROR = "Could not focus on an element inside the focus trap when activated (see details below).\n\n- your focus trap should contain at least one focusable element\n- or a focusable element should be provided to `elementToFocusWhenActivated`\n";
var DEACTIVATION_FOCUS_ERROR = "Could not focus on an element outside the focus trap when deactivated (see details below).\n\n- the element that was focused before activating the trap should still exists\n- or a focusable element should be provided to `elementToFocusWhenDeactivated`\n";
var focusTrapsManager = createFocusTrapsManager();
function createFocusTrapsManager() {
    /** A list of focus traps in use, ordered with the current one at the front, and so on… */
    var focusTrapsInUse = [];
    return {
        add: function (focusTrap) {
            // pause the focus trap currently in use (at the front)
            var currentFocusTrap = focusTrapsInUse[0];
            if (focusTrap !== currentFocusTrap) {
                currentFocusTrap === null || currentFocusTrap === void 0 ? void 0 : currentFocusTrap.pause();
            }
            var isFocusTrapAlreadyInUse = focusTrapsInUse.includes(focusTrap);
            if (isFocusTrapAlreadyInUse) {
                // move the existing trap to the front
                focusTrapsInUse = arrayRemove(focusTrapsInUse, focusTrap);
                focusTrapsInUse.unshift(focusTrap);
            }
            else {
                focusTrapsInUse.unshift(focusTrap);
            }
        },
        remove: function (focusTrap) {
            var _a;
            focusTrapsInUse = arrayRemove(focusTrapsInUse, focusTrap);
            (_a = focusTrapsInUse[0]) === null || _a === void 0 ? void 0 : _a.resume();
        },
    };
}

var LockContextProvider = React.createContext({});
function Lock(_a) {
    var children = _a.children, _b = _a.isActive, isActive = _b === void 0 ? false : _b, _c = _a.onDeactivate, onDeactivate = _c === void 0 ? function () { } : _c, refToFocusOnActivation = _a.refToFocusOnActivation, refToFocusOnDeactivation = _a.refToFocusOnDeactivation, shouldDeactivateOnEscape = _a.shouldDeactivateOnEscape, shouldDeactivateOnOutsideClick = _a.shouldDeactivateOnOutsideClick, shouldBlockOutsideClick = _a.shouldBlockOutsideClick, shouldLockScroll = _a.shouldLockScroll;
    /**
     * A ref to set on the container element in which we want to trap focus
     * NOTE: we do not support the case where that container would dynamically change.
     */
    var containerRef = React.useRef();
    /** A ref to the focus trap  */
    var focusTrapRef = React.useRef();
    // keep track of whether we need to prevent the focus control when the focus trap is deactivated
    var shouldPreventFocusControlWhenDeactivatedRef = React.useRef(false);
    // grab the previous function that deactivates all locks which are parents to this one
    var _d = React.useContext(LockContextProvider), deactivateParentLocksFromContext = _d.deactivateParentLocks, shouldDeactivateOnOutsideClickFromContext = _d.shouldDeactivateOnOutsideClick;
    // build up a new function to deactivate all locks to pass down to the eventual children locks (through context)
    var deactivateThisLockAndItsParents = React.useCallback(function (shouldPreventFocusControl) {
        var hasParentLock = deactivateParentLocksFromContext !== undefined;
        // NOTE: make sure we update the ref before calling `onDeactivate` so it's setup on time
        // for when the deactivation actually happens in each Lock (where `shouldPreventFocusControlWhenDeactivatedRef` is read)
        shouldPreventFocusControlWhenDeactivatedRef.current = hasParentLock
            ? true // prevent focus control for intermediary locks in a stack of locks
            : shouldPreventFocusControl;
        // deactivate this lock
        onDeactivate();
        // deactivate its parents
        if (deactivateParentLocksFromContext) {
            deactivateParentLocksFromContext(shouldPreventFocusControl);
        }
    }, [onDeactivate, deactivateParentLocksFromContext]);
    // Create the focus trap on mount
    // Deactivate it on unmount
    React.useEffect(function () {
        if (containerRef.current) {
            focusTrapRef.current = createFocusTrap({
                container: containerRef.current,
            });
        }
        return function () {
            var _a;
            (_a = focusTrapRef.current) === null || _a === void 0 ? void 0 : _a.deactivate({
                shouldPreventFocusControl: shouldPreventFocusControlWhenDeactivatedRef.current,
            });
            // reset
            shouldPreventFocusControlWhenDeactivatedRef.current = false;
        };
    }, []);
    // Synchronize changes to `isActive`
    React.useEffect(function () {
        var _a, _b;
        if (isActive) {
            (_a = focusTrapRef.current) === null || _a === void 0 ? void 0 : _a.activate();
        }
        else {
            (_b = focusTrapRef.current) === null || _b === void 0 ? void 0 : _b.deactivate({
                shouldPreventFocusControl: shouldPreventFocusControlWhenDeactivatedRef.current,
            });
            // reset
            shouldPreventFocusControlWhenDeactivatedRef.current = false;
        }
    }, [isActive]);
    var onOutsideClickHandler = React.useCallback(function (event, shouldPreventFocusControl) {
        // NOTE: make sure we update the ref before calling `onDeactivate` so it's setup on time
        shouldPreventFocusControlWhenDeactivatedRef.current = shouldPreventFocusControl;
        onDeactivate();
        // kick-off deactivating all the parent Locks only if top-level lock isn't blocking clicks
        if (!shouldBlockOutsideClick) {
            if (deactivateParentLocksFromContext) {
                deactivateParentLocksFromContext(shouldPreventFocusControl);
            }
        }
    }, [onDeactivate, shouldBlockOutsideClick, deactivateParentLocksFromContext]);
    // Synchronise config changes
    React.useEffect(function () {
        var _a;
        (_a = focusTrapRef.current) === null || _a === void 0 ? void 0 : _a.updateConfig({
            elementToFocusWhenActivated: refToFocusOnActivation === null || refToFocusOnActivation === void 0 ? void 0 : refToFocusOnActivation.current,
            elementToFocusWhenDeactivated: refToFocusOnDeactivation === null || refToFocusOnDeactivation === void 0 ? void 0 : refToFocusOnDeactivation.current,
            shouldDeactivateOnEscape: shouldDeactivateOnEscape,
            onEscape: onDeactivate,
            shouldDeactivateOnOutsideClick: 
            // prioritize the configuration coming from the parent Lock over the prop
            shouldDeactivateOnOutsideClickFromContext !== null && 
            // prioritize the configuration coming from the parent Lock over the prop
            shouldDeactivateOnOutsideClickFromContext !== void 0 ? 
            // prioritize the configuration coming from the parent Lock over the prop
            shouldDeactivateOnOutsideClickFromContext : shouldDeactivateOnOutsideClick,
            onOutsideClick: onOutsideClickHandler,
            shouldBlockOutsideClick: shouldBlockOutsideClick,
            shouldLockScroll: shouldLockScroll,
        });
    }, [
        refToFocusOnActivation,
        refToFocusOnDeactivation,
        shouldDeactivateOnEscape,
        onDeactivate,
        shouldDeactivateOnOutsideClick,
        shouldDeactivateOnOutsideClickFromContext,
        onOutsideClickHandler,
        shouldBlockOutsideClick,
        shouldLockScroll,
    ]);
    var content;
    if (typeof children === 'function') {
        // useful for cases when we need to attach the container ref to a specific element
        // other than the first child node (used in Popover for example)
        content = children(containerRef);
    }
    else {
        var child = React.Children.only(children);
        content = React.cloneElement(child, {
            // compose all the possible refs to the container element
            ref: composeRefs(child.ref, containerRef),
        });
    }
    // finally, clone our container, attaching the composed ref to it
    return (React.createElement(LockContextProvider.Provider, { value: {
            deactivateParentLocks: deactivateThisLockAndItsParents,
            shouldDeactivateOnOutsideClick: 
            // ensure the configuration passed to each child is the one from the top-most parent Lock
            shouldDeactivateOnOutsideClickFromContext !== null && 
            // ensure the configuration passed to each child is the one from the top-most parent Lock
            shouldDeactivateOnOutsideClickFromContext !== void 0 ? 
            // ensure the configuration passed to each child is the one from the top-most parent Lock
            shouldDeactivateOnOutsideClickFromContext : shouldDeactivateOnOutsideClick,
        } }, content));
}

var Dialog = React.forwardRef(function Dialog(props, forwardedRef) {
    var children = props.children, isOpen = props.isOpen, onClose = props.onClose, refToFocusOnOpen = props.refToFocusOnOpen, refToFocusOnClose = props.refToFocusOnClose, _a = props.shouldCloseOnEscape, shouldCloseOnEscape = _a === void 0 ? true : _a, _b = props.shouldCloseOnOutsideClick, shouldCloseOnOutsideClick = _b === void 0 ? true : _b, styleConfig = props.styleConfig, contentProps = __rest(props, ["children", "isOpen", "onClose", "refToFocusOnOpen", "refToFocusOnClose", "shouldCloseOnEscape", "shouldCloseOnOutsideClick", "styleConfig"]);
    var debugContext = useDebugContext();
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var overlayStyles = getPartStyles('overlay', styleConfig, variantsMap);
    var wrapperStyles = getPartStyles('wrapper', styleConfig, variantsMap);
    var contentStyles = getPartStyles('content', styleConfig, variantsMap);
    return (React.createElement(PresenceTransition, { isPresent: isOpen },
        React.createElement(Portal, null,
            React.createElement(Overlay
            // at this point `overlayStyles` already has the variants applied
            // so we can just create styleConfig with base styles on the fly
            , { 
                // at this point `overlayStyles` already has the variants applied
                // so we can just create styleConfig with base styles on the fly
                styleConfig: {
                    base: { overlay: overlayStyles },
                }, style: { pointerEvents: debugContext.disableLock ? 'none' : 'auto' } }),
            React.createElement(WrapperPart$1, { wrapperStyles: wrapperStyles },
                React.createElement(Lock, { isActive: debugContext.disableLock ? false : isOpen, onDeactivate: onClose, refToFocusOnActivation: refToFocusOnOpen, refToFocusOnDeactivation: refToFocusOnClose, shouldDeactivateOnEscape: shouldCloseOnEscape, shouldDeactivateOnOutsideClick: shouldCloseOnOutsideClick, shouldBlockOutsideClick: true, shouldLockScroll: true }, function (lockContainerRef) { return (React.createElement(PartTransition, null,
                    React.createElement(ContentPart, __assign({}, contentProps, { ref: composeRefs(forwardedRef, lockContainerRef), 
                        // accessibility
                        role: "dialog", "aria-modal": true, 
                        // other props
                        contentStyles: contentStyles }), children))); })))));
});
Dialog.displayName = 'Dialog';
var WrapperPart$1 = styled('div').attrs({ 'data-part-id': 'wrapper' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'fixed',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: 'none',
}, 
// apply style config
function (_a) {
    var _b = _a.wrapperStyles, wrapperStyles = _b === void 0 ? {} : _b;
    return wrapperStyles.normal;
});
WrapperPart$1.displayName = 'WrapperPart';
var ContentPart = styled('div').attrs({ 'data-part-id': 'content' })(
// reset styles
cssReset('div'), 
// functional styles
{
    pointerEvents: 'auto',
}, 
// apply style config
function (_a) {
    var _b = _a.contentStyles, contentStyles = _b === void 0 ? {} : _b;
    var normal = contentStyles.normal, enter = contentStyles.enter, opened = contentStyles.opened, exit = contentStyles.exit;
    return __assign(__assign({}, normal), { '&.enter, &.appear': enter, '&.enter-active, &.appear-active': opened, '&.exit': opened, '&.exit-active': exit });
}, 
// add system support
boxSystemProps);
ContentPart.displayName = 'ContentPart';

var systemProps$f = boxSystemProps;
var Divider = React.forwardRef(function Divider(props, forwardedRef) {
    var styleConfig = props.styleConfig, dividerProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var dividerStyles = getPartStyles('divider', styleConfig, variantsMap);
    return React.createElement(DividerPart, __assign({}, dividerProps, { ref: forwardedRef, dividerStyles: dividerStyles }));
});
Divider.displayName = 'Divider';
var DividerPart = styled('hr').attrs({ 'data-part-id': 'divider' })(
// reset styles
cssReset('hr'), 
// apply style config
function (_a) {
    var _b = _a.dividerStyles, dividerStyles = _b === void 0 ? {} : _b;
    return dividerStyles.normal;
}, 
// add system support
systemProps$f);
DividerPart.displayName = 'DividerPart';

var id = 0;
var makeId = function () {
    id = id + 1;
    return id;
};
var useId = function () {
    var id = React.useState(function () { return makeId(); })[0];
    return id;
};

/**
 * Creates a rect (`ClientRect`) based on a Size and and a position (x, y).
 * This is useful to compute the rect of an element without having to actually move it.
 */
function makeRect(_a, _b) {
    var width = _a.width, height = _a.height;
    var x = _b.x, y = _b.y;
    return {
        width: width,
        height: height,
        top: y,
        bottom: y + height,
        left: x,
        right: x + width,
    };
}
/**
 * Gets the rect (`ClientRect`) of an element and rounds all values.
 */
function getRoundedRect(element) {
    var rect = element.getBoundingClientRect();
    return {
        width: Math.round(rect.width),
        height: Math.round(rect.height),
        top: Math.round(rect.top),
        right: Math.round(rect.right),
        bottom: Math.round(rect.bottom),
        left: Math.round(rect.left),
    };
}
/**
 * Gets the opposite side of a given side (ie. top => bottom, left => right, …)
 */
function getOppositeSide(side) {
    var oppositeSides = {
        top: 'bottom',
        right: 'left',
        bottom: 'top',
        left: 'right',
    };
    return oppositeSides[side];
}
/**
 * Returns whether 2 rects are equal in values
 */
function rectEquals(rect1, rect2) {
    return (rect1.width === rect2.width &&
        rect1.height === rect2.height &&
        rect1.top === rect2.top &&
        rect1.right === rect2.right &&
        rect1.bottom === rect2.bottom &&
        rect1.left === rect2.left);
}

function clamp(value, _a) {
    var min = _a[0], max = _a[1];
    return Math.min(max, Math.max(min, value));
}

function getElementBoxModelStyles(element) {
    var boxModelProperties = [
        'borderTopWidth',
        'borderRightWidth',
        'borderBottomWidth',
        'borderLeftWidth',
        'paddingTop',
        'paddingRight',
        'paddingBottom',
        'paddingLeft',
    ];
    var computedStyles = window.getComputedStyle(element);
    return boxModelProperties.reduce(function (stylesMap, property) {
        var _a;
        return (__assign(__assign({}, stylesMap), (_a = {}, _a[property] = getUnitlessPxValue(computedStyles[property]), _a)));
    }, {});
}
function getUnitlessPxValue(pxValue) {
    if (pxValue === null) {
        return 0;
    }
    return Number(pxValue.replace('px', ''));
}

/**
 * Calculates the position and size of a standard menu
 */
function calculateMenuPosition(_a) {
    var anchorRect = _a.anchorRect, menuWrapper = _a.menuWrapper, menuItemsWrapper = _a.menuItemsWrapper, referenceItem = _a.referenceItem, viewportGap = _a.viewportGap;
    if (!anchorRect || !menuWrapper || !menuItemsWrapper || !referenceItem) {
        return undefined;
    }
    var viewportSize = { width: window.innerWidth, height: window.innerHeight };
    var usableSpaceAboveAnchor = anchorRect.top - viewportGap;
    var usableSpaceBelowAnchor = viewportSize.height - anchorRect.bottom - viewportGap;
    var menuWrapperRect = getRoundedRect(menuWrapper);
    var menuSize = { width: menuWrapperRect.width, height: menuWrapperRect.height };
    var itemsHeight = menuItemsWrapper.scrollHeight;
    var menuHeightWithoutItems = menuSize.height - itemsHeight;
    var referenceItemHeight = referenceItem.offsetHeight;
    var minScrollPaneHeight = referenceItemHeight * 3;
    var maxScrollPaneHeight = viewportSize.height - viewportGap * 2 - menuHeightWithoutItems;
    var canFitMenuAboveAnchor = menuSize.height <= usableSpaceAboveAnchor;
    var canFitMenuBelowAnchor = menuSize.height <= usableSpaceBelowAnchor;
    var isMenuBelowAnchorTallEnough = usableSpaceBelowAnchor - menuHeightWithoutItems >= minScrollPaneHeight;
    var hasRightCollision = anchorRect.left + menuSize.width > viewportSize.width - viewportGap;
    // our final values
    var menuX = anchorRect.left;
    var menuY = anchorRect.bottom;
    var scrollPaneHeight = Math.min(itemsHeight, maxScrollPaneHeight);
    var scrollTop = undefined;
    // horizontal collisions
    if (hasRightCollision) {
        var alignedRightWithAnchor = anchorRect.right - menuSize.width;
        menuX = alignedRightWithAnchor;
    }
    var atViewportRightEdge = viewportSize.width - menuSize.width - viewportGap;
    menuX = clamp(menuX, [viewportGap, atViewportRightEdge]);
    // vertical collisions
    if (canFitMenuBelowAnchor || isMenuBelowAnchorTallEnough) {
        var belowAnchor = anchorRect.bottom;
        var atViewportTopEdge = viewportGap;
        menuY = Math.max(belowAnchor, atViewportTopEdge);
        if (!canFitMenuBelowAnchor) {
            scrollPaneHeight = Math.min(usableSpaceBelowAnchor - menuHeightWithoutItems, maxScrollPaneHeight);
        }
    }
    else {
        if (!canFitMenuAboveAnchor) {
            scrollPaneHeight = Math.min(usableSpaceAboveAnchor - menuHeightWithoutItems, maxScrollPaneHeight);
            scrollTop = itemsHeight; // force scroll all the way down
        }
        var newMenuHeight = scrollPaneHeight + menuHeightWithoutItems;
        var aboveAnchor = anchorRect.top - newMenuHeight;
        var atViewportBottomEdge = viewportSize.height - newMenuHeight - viewportGap;
        menuY = Math.min(aboveAnchor, atViewportBottomEdge);
    }
    return { x: menuX, y: menuY, scrollPaneHeight: scrollPaneHeight, scrollTop: scrollTop };
}
/**
 * Calculates the position and size of a right click menu
 */
function calculateRightClickMenuPosition(_a) {
    var anchorRect = _a.anchorRect, menuWrapper = _a.menuWrapper, menuItemsWrapper = _a.menuItemsWrapper, viewportGap = _a.viewportGap;
    if (!anchorRect || !menuWrapper || !menuItemsWrapper) {
        return undefined;
    }
    var viewportSize = { width: window.innerWidth, height: window.innerHeight };
    var usableSpaceBelowAnchor = viewportSize.height - anchorRect.bottom - viewportGap;
    var menuWrapperRect = getRoundedRect(menuWrapper);
    var menuSize = { width: menuWrapperRect.width, height: menuWrapperRect.height };
    var itemsHeight = menuItemsWrapper.scrollHeight;
    var menuHeightWithoutItems = menuSize.height - itemsHeight;
    var maxScrollPaneHeight = viewportSize.height - viewportGap * 2 - menuHeightWithoutItems;
    var canFitMenuBelowAnchor = menuSize.height <= usableSpaceBelowAnchor;
    var hasRightCollision = anchorRect.left + menuSize.width > viewportSize.width - viewportGap;
    // our final values
    var menuX = anchorRect.left;
    var menuY = anchorRect.bottom;
    var scrollPaneHeight = Math.min(itemsHeight, maxScrollPaneHeight);
    // horizontal collisions
    if (hasRightCollision) {
        var alignedRightWithAnchor = anchorRect.right - menuSize.width;
        menuX = alignedRightWithAnchor;
    }
    var atViewportRightEdge = viewportSize.width - menuSize.width - viewportGap;
    menuX = clamp(menuX, [viewportGap, atViewportRightEdge]);
    // vertical collisions
    if (!canFitMenuBelowAnchor) {
        var bottomOverflow = menuSize.height - usableSpaceBelowAnchor;
        menuY -= bottomOverflow;
    }
    menuY = Math.max(menuY, viewportGap);
    return { x: menuX, y: menuY, scrollPaneHeight: scrollPaneHeight };
}
/**
 * Calculates the position and size of a select menu
 */
function calculateSelectMenuPosition(_a) {
    var buttonRect = _a.anchorRect, buttonText = _a.anchorText, menuWrapper = _a.menuWrapper, menu = _a.menu, menuItemsWrapper = _a.menuItemsWrapper, scrollIndicator = _a.scrollIndicator, selectedOption = _a.referenceItem, selectedOptionText = _a.referenceItemText, viewportGap = _a.viewportGap;
    if (!buttonRect ||
        !buttonText ||
        !menuWrapper ||
        !menu ||
        !menuItemsWrapper ||
        !scrollIndicator ||
        !selectedOption ||
        !selectedOptionText) {
        return undefined;
    }
    // VIEWPORT INFO
    //
    var viewportWidth = window.innerWidth;
    var viewportHeight = window.innerHeight;
    // BUTTON INFO
    //
    var buttonTop = Math.round(buttonRect.top);
    var buttonBottom = Math.round(buttonRect.bottom);
    var buttonLeft = Math.round(buttonRect.left);
    var buttonWidth = buttonRect.width;
    var buttonTextLeft = buttonText.getBoundingClientRect().left;
    // MENU INFO
    //
    var menuStyles = getElementBoxModelStyles(menu);
    var spaceAboveOptions = menuStyles.paddingTop + menuStyles.borderTopWidth;
    var optionsHeight = menuItemsWrapper.scrollHeight;
    var spaceBelowOptions = menuStyles.paddingBottom + menuStyles.borderBottomWidth;
    var menuWidth = menu.getBoundingClientRect().width;
    var menuHeight = spaceAboveOptions + optionsHeight + spaceBelowOptions;
    var scrollIndicatorHeight = scrollIndicator.offsetHeight;
    // SELECTED OPTION INFO
    //
    var selectedOptionHeight = selectedOption.offsetHeight;
    var selectedOptionTextOffset = selectedOptionText.offsetLeft;
    // the reason this calculation works is because `selectedOption.offsetTop`
    // is relative to the closest `position: relative|absolute` parent, in our case the menu.
    // however, it doesn't take into account the borderTop of the menu, so we only need to
    // subtract the padding top
    var distanceFromScrollPaneTopToSelectedOptionTop = selectedOption.offsetTop - menuStyles.paddingTop;
    // SCROLL PANE INFO
    //
    var minScrollPaneHeight = selectedOptionHeight * 3;
    var maxAvailableScrollPaneHeight = viewportHeight - spaceAboveOptions - spaceBelowOptions - viewportGap * 2;
    var maxScrollPaneHeight = Math.min(optionsHeight, maxAvailableScrollPaneHeight);
    // BASIC OFFSET INFO
    //
    // we calculate an offset to make sure we always center align with the button
    // in case the button and the option don't have the same height
    var verticalCenterOffset = (buttonRect.height - selectedOptionHeight) / 2;
    // the offset to place the menu so the selected option is aligned on the button
    // this will always be a negative value, as we are moving the menu up
    var offsetTop = -spaceAboveOptions - distanceFromScrollPaneTopToSelectedOptionTop + verticalCenterOffset;
    // this is the position of the menu, always aligning the option to the button
    // regardless of collisions on either top or bottom, regardless of resulting menu height
    // basically, before we do any edge case adjustments
    var unadjustedMenuY = buttonTop + offsetTop;
    var unadjustedMenuX = buttonTextLeft - menuStyles.paddingLeft - menuStyles.borderLeftWidth - selectedOptionTextOffset;
    // TOP CALCULATIONS
    //
    var hasTopCollision = unadjustedMenuY < viewportGap;
    var topOverflow = Math.abs(unadjustedMenuY - viewportGap);
    var menuHeightIfAtTop = optionsHeight - topOverflow;
    var buttonIsLowEnough = buttonTop >= viewportGap + Math.max(scrollIndicatorHeight, menuStyles.paddingTop) + menuStyles.borderTopWidth;
    var menuAtTopIsHighEnough = menuHeightIfAtTop - scrollIndicatorHeight + menuStyles.paddingTop >= minScrollPaneHeight;
    var canAlignAtTop = buttonIsLowEnough && menuAtTopIsHighEnough;
    // BOTTOMS CALCULATIONS
    //
    var unadjustedMenuBottom = unadjustedMenuY + menuHeight;
    var hasBottomCollision = unadjustedMenuBottom > viewportHeight - viewportGap;
    var bottomOverflow = Math.abs(viewportHeight - viewportGap - unadjustedMenuBottom);
    var menuHeightIfAtBottom = optionsHeight - bottomOverflow;
    var buttonIsHighEnough = viewportHeight - buttonBottom >=
        viewportGap + Math.max(scrollIndicatorHeight, menuStyles.paddingBottom) + menuStyles.borderBottomWidth;
    var menuAtBottomIsHighEnough = menuHeightIfAtBottom - scrollIndicatorHeight + menuStyles.paddingBottom >= minScrollPaneHeight;
    var canAlignAtBottom = buttonIsHighEnough && menuAtBottomIsHighEnough;
    // THE FINAL VALUES WE ARE COMPUTING
    //
    var menuX = unadjustedMenuX;
    var menuY = unadjustedMenuY;
    var width = undefined;
    var scrollPaneHeight = optionsHeight;
    var scrollTop = 0;
    // width (menu doesn't pass right edge of button)
    var xAdjustment = buttonLeft - unadjustedMenuX;
    if (menuWidth - xAdjustment < buttonWidth) {
        width = buttonWidth + xAdjustment;
    }
    // left edge (menu doesn't fit on the left)
    if (menuX < viewportGap) {
        menuX = viewportGap;
    }
    // right edge (menu doesn't fit on the right)
    else if (menuX + menuWidth > viewportWidth - viewportGap) {
        menuX = viewportWidth - menuWidth - viewportGap;
    }
    // top edge case (cannot be aligned or menu would be too small)
    if (hasTopCollision && !canAlignAtTop) {
        // stretch the menu as high as possible
        scrollPaneHeight = maxScrollPaneHeight;
        // align to the top of viewport
        menuY = viewportGap;
        // try to scroll to reveal the selected option as close as possible to the top
        var topCompensationDiff = menuStyles.paddingTop - scrollIndicatorHeight;
        var topScrollCompensation = topCompensationDiff >= 0 ? 0 : Math.abs(topCompensationDiff);
        var topScrollThreshold = distanceFromScrollPaneTopToSelectedOptionTop - topScrollCompensation;
        scrollTop = topScrollThreshold;
    }
    // bottom edge case (cannot be aligned or menu would be too small)
    else if (hasBottomCollision && !canAlignAtBottom) {
        // stretch the menu as high as possible
        scrollPaneHeight = maxScrollPaneHeight;
        // align to the bottom of viewport
        var newMenuHeight = spaceAboveOptions + scrollPaneHeight + spaceBelowOptions;
        menuY = viewportHeight - newMenuHeight - viewportGap;
        // try to scroll to reveal the selected option as close as possible to the bottom
        var bottomCompensationDiff = menuStyles.paddingBottom - scrollIndicatorHeight;
        var bottomScrollCompensation = bottomCompensationDiff >= 0 ? 0 : Math.abs(bottomCompensationDiff);
        var bottomScrollThreshold = distanceFromScrollPaneTopToSelectedOptionTop + selectedOptionHeight - scrollPaneHeight + bottomScrollCompensation;
        scrollTop = bottomScrollThreshold;
    }
    // we can align
    else {
        // we have a collision at the top
        if (hasTopCollision) {
            // reduce the menu height by the amount overflowing at the top
            scrollPaneHeight -= topOverflow;
            // move the menu down by that same amount
            menuY = unadjustedMenuY + topOverflow;
            // compensate the scroll position by that same amount
            scrollTop = topOverflow;
        }
        // we have a collision at the bottom
        if (hasBottomCollision) {
            // reduce the menu height by the amount overflowing at the bottom
            scrollPaneHeight -= bottomOverflow;
        }
    }
    return { x: menuX, y: menuY, width: width, scrollPaneHeight: scrollPaneHeight, scrollTop: scrollTop };
}
function setMenuPosition(options) {
    var menuWrapper = options.menuWrapper, menuScrollPane = options.menuScrollPane, menuPosition = options.menuPosition;
    var x = menuPosition.x, y = menuPosition.y, width = menuPosition.width, scrollPaneHeight = menuPosition.scrollPaneHeight, scrollTop = menuPosition.scrollTop;
    // move menu in place
    menuWrapper.style.left = window.pageXOffset + x + 'px';
    menuWrapper.style.top = window.pageYOffset + y + 'px';
    if (width !== undefined) {
        menuWrapper.style.width = width + 'px';
    }
    // resize scrollable area of the menu
    menuScrollPane.style.height = scrollPaneHeight + 'px';
    // scroll if necessary
    if (scrollTop !== undefined) {
        menuScrollPane.scrollTop = scrollTop;
    }
}

function composeEventHandlers(originalEventHandler, ourEventHandler, _a) {
    var _b = (_a === void 0 ? {} : _a).checkForDefaultPrevented, checkForDefaultPrevented = _b === void 0 ? true : _b;
    return function handleEvent(event) {
        originalEventHandler === null || originalEventHandler === void 0 ? void 0 : originalEventHandler(event);
        if (checkForDefaultPrevented === false || !event.defaultPrevented) {
            return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
        }
    };
}

function useDropdownMenu(_a) {
    var menuIdProp = _a.menuId;
    var generatedDropdownMenuId = "dropdownMenu-" + useId();
    var menuId = menuIdProp || generatedDropdownMenuId;
    var _b = React.useState(false), isOpen = _b[0], setIsOpen = _b[1];
    var buttonRef = React.useRef(null);
    var getButtonProps = function (props) {
        if (props === void 0) { props = {}; }
        var ref = props.ref, originalOnMouseDown = props.onMouseDown, originalOnKeyDown = props.onKeyDown;
        return __assign(__assign({}, props), { 
            // accessibility
            'aria-haspopup': 'menu', 'aria-expanded': isOpen ? true : undefined, 'aria-controls': isOpen ? menuId : undefined, 
            // other props
            ref: composeRefs(ref, buttonRef), onMouseDown: composeEventHandlers(originalOnMouseDown, function () { return setIsOpen(true); }), onKeyDown: composeEventHandlers(originalOnKeyDown, function (event) {
                if (event.key === ' ' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    event.preventDefault();
                    setIsOpen(true);
                }
            }) });
    };
    var getMenuProps = function () {
        return {
            // accessibility
            id: menuId,
            // other props
            buttonRef: buttonRef,
            isOpen: isOpen,
            onClose: function () { return setIsOpen(false); },
            calculateMenuPosition: calculateMenuPosition,
        };
    };
    return {
        isOpen: isOpen,
        getButtonProps: getButtonProps,
        getMenuProps: getMenuProps,
    };
}
function DropdownMenu(_a) {
    var button = _a.button, menu = _a.menu;
    var menuId = React.Children.only(menu).props.id;
    var _b = useDropdownMenu({ menuId: menuId }), isOpen = _b.isOpen, getButtonProps = _b.getButtonProps, getMenuProps = _b.getMenuProps;
    var wiredButton = typeof button === 'function'
        ? button(isOpen, getButtonProps)
        : React.cloneElement(button, getButtonProps(__assign(__assign({}, button.props), { ref: button.ref })));
    var wiredMenu = React.cloneElement(menu, getMenuProps());
    return (React.createElement(React.Fragment, null,
        wiredButton,
        wiredMenu));
}

var Flex = React.forwardRef(function Flex(props, forwardedRef) {
    return React.createElement(FlexPart, __assign({}, props, { ref: forwardedRef }));
});
Flex.displayName = 'Flex';
var FlexPart = styled('div').attrs({ 'data-part-id': 'flex' })(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'flex',
}, 
// add system props
boxSystemProps);
FlexPart.displayName = 'FlexPart';

var Grid = React.forwardRef(function Grid(props, forwardedRef) {
    return React.createElement(GridPart, __assign({}, props, { ref: forwardedRef }));
});
Grid.displayName = 'Grid';
var GridPart = styled('div').attrs({ 'data-part-id': 'grid' })(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'grid',
}, 
// add system props
boxSystemProps);
GridPart.displayName = 'GridPart';

var systemProps$g = boxSystemProps;
var Header = React.forwardRef(function Header(props, forwardedRef) {
    var styleConfig = props.styleConfig, headerProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var headerStyles = getPartStyles('header', styleConfig, variantsMap);
    return React.createElement(HeaderPart, __assign({}, headerProps, { ref: forwardedRef, headerStyles: headerStyles }));
});
Header.displayName = 'Header';
var HeaderPart = styled('header').attrs({ 'data-part-id': 'header' })(
// reset styles
cssReset('header'), 
// functional styles
function (_a) {
    var _b = _a.isSticky, isSticky = _b === void 0 ? false : _b;
    if (Boolean(isSticky)) {
        return {
            position: 'sticky',
            top: 0,
        };
    }
}, 
// apply style config
function (_a) {
    var _b = _a.headerStyles, headerStyles = _b === void 0 ? {} : _b;
    return headerStyles.normal;
}, 
// add system support
systemProps$g);
HeaderPart.displayName = 'HeaderPart';

var systemProps$h = boxSystemProps;
var Input$1 = React.forwardRef(function Input(props, forwardedRef) {
    var styleConfig = props.styleConfig, inputProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var inputStyles = getPartStyles('input', styleConfig, variantsMap);
    var placeholderStyles = getPartStyles('placeholder', styleConfig, variantsMap);
    return (React.createElement(InputPart, __assign({}, inputProps, { ref: forwardedRef, inputStyles: inputStyles, placeholderStyles: placeholderStyles })));
});
Input$1.displayName = 'Input';
var InputPart = styled('input').attrs({ 'data-part-id': 'input' })(
// reset styles
cssReset('input'), 
// functional styles
{
    lineHeight: '1',
    '&:disabled': { pointerEvents: 'none' },
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.inputStyles, inputStyles = _c === void 0 ? {} : _c, _d = _a.placeholderStyles, placeholderStyles = _d === void 0 ? {} : _d;
    var normal = inputStyles.normal, hover = inputStyles.hover, focus = inputStyles.focus, active = inputStyles.active, readOnly = inputStyles.readOnly, disabled = inputStyles.disabled;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active, '&:read-only': readOnly, '&:disabled': disabled, 
        // Fix auto-filled input font-size (doesn't work with 'inherit')
        '&:-webkit-autofill::first-line': {
            fontSize: (_b = inputStyles.normal) === null || _b === void 0 ? void 0 : _b.fontSize,
        }, '&::-webkit-input-placeholder': placeholderStyles.normal, '&::-moz-placeholder': placeholderStyles.normal, '&:-ms-input-placeholder': placeholderStyles.normal });
}, 
// add system support
systemProps$h);
InputPart.displayName = 'InputPart';

var systemProps$i = boxSystemProps;
var Link = React.forwardRef(function Link(props, forwardedRef) {
    var styleConfig = props.styleConfig, linkProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var linkStyles = getPartStyles('link', styleConfig, variantsMap);
    return React.createElement(LinkPart, __assign({}, linkProps, { ref: forwardedRef, linkStyles: linkStyles }));
});
Link.displayName = 'Link';
var LinkPart = styled('a').attrs({ 'data-part-id': 'link' })(
// reset styles
cssReset('a'), 
// apply style config
function (_a) {
    var _b = _a.linkStyles, linkStyles = _b === void 0 ? {} : _b;
    var normal = linkStyles.normal, hover = linkStyles.hover, focus = linkStyles.focus, active = linkStyles.active;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active });
}, 
// add system support
systemProps$i);
LinkPart.displayName = 'LinkPart';

function useSelfResettingState(initialValue, waitInMs) {
    if (waitInMs === void 0) { waitInMs = 1000; }
    var _a = React.useState(initialValue), value = _a[0], setValue = _a[1];
    // we setup an effect with a timer which resets the value after `waitInMs` expires
    // we make sure whenever `initialValue` or `waitInMs` change,
    // but most importantly if `value` changes, we clean up and re-run the effect
    // effectively clearing the timer and re-setting a new one.
    React.useEffect(function () {
        var timerId = window.setTimeout(function () {
            setValue(initialValue);
        }, waitInMs);
        return function () {
            clearTimeout(timerId);
        };
    }, [value, initialValue, waitInMs]);
    return [value, setValue];
}

function usePrevious(value) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    var ref = React.useRef();
    // Store current value in ref
    React.useEffect(function () {
        ref.current = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)
    return ref.current;
}

function isSelectableItem(item) {
    return (
    // disabled items are not selectable
    !item.isDisabled &&
        // undefined items are not selectable
        !(item.value === undefined && item.label === undefined));
}
function getSelectableItems(items) {
    return items.filter(isSelectableItem);
}
function getItemIndexForValue(items, value) {
    return items.findIndex(function (item) { return item.value === value; });
}
function getItemLabelForValue(items, value) {
    var item = items.find(function (item) { return item.value === value; });
    return item ? item.label : '';
}
function getMatchingItems(items, searchString) {
    return items.filter(function (item) { return item.label.toLowerCase().startsWith(searchString.toLowerCase()); });
}
function getFirstSelectableIndex(items) {
    var selectableItems = getSelectableItems(items);
    if (selectableItems.length === 0) {
        return undefined;
    }
    var firstSelectableItem = selectableItems[0];
    return items.indexOf(firstSelectableItem);
}
function getLastSelectableIndex(items) {
    var selectableItems = getSelectableItems(items);
    if (selectableItems.length === 0) {
        return undefined;
    }
    var lastSelectableItem = selectableItems[selectableItems.length - 1];
    return items.indexOf(lastSelectableItem);
}
function getNextSelectableIndex(_a) {
    var items = _a.items, currentIndex = _a.currentIndex, key = _a.key;
    if (currentIndex === undefined) {
        // we start at the top / bottom based on the arrow key pressed
        return key === 'ArrowDown' ? getFirstSelectableIndex(items) : getLastSelectableIndex(items);
    }
    var increment = key === 'ArrowDown' ? 1 : -1;
    // we start looking down / up
    var nextIndex = currentIndex + increment;
    // while we're still in bounds
    while (nextIndex >= 0 && nextIndex <= items.length - 1) {
        var nextItem = items[nextIndex];
        // we have found our next selectable item
        // we can exit
        if (isSelectableItem(nextItem)) {
            return nextIndex;
        }
        nextIndex += increment;
    }
    // we couldn't find the next selectable index so we return the current one.
    return currentIndex;
}

var DEFAULT_VIEWPORT_GAP = 10;
/**
 * Sets up a scroll listener to expand the menu on scroll.
 *
 * This behaviour happens when the menu is not using its maximum height
 * because of initially prioritizing:
 * - better placement (below a button for a menu button)
 * - better alignment (for a custom select menu)
 */
function startExpandingMenuOnScroll(_a) {
    var menuWrapper = _a.menuWrapper, menu = _a.menu, menuScrollPane = _a.menuScrollPane, menuItemsWrapper = _a.menuItemsWrapper, viewportGap = _a.viewportGap;
    function handleMenuScroll(event) {
        // we need a reference to these elements
        if (!menuWrapper || !menu || !menuScrollPane || !menuItemsWrapper) {
            return;
        }
        // VIEWPORT INFO
        //
        var viewportHeight = window.innerHeight;
        // MENU INFO
        //
        var menuStyles = getElementBoxModelStyles(menu);
        var spaceAboveItems = menuStyles.paddingTop + menuStyles.borderTopWidth;
        var itemsHeight = menuItemsWrapper.scrollHeight;
        var spaceBelowItems = menuStyles.paddingBottom + menuStyles.borderBottomWidth;
        var menuWrapperRect = menuWrapper.getBoundingClientRect();
        // SCROLL PANE INFO
        //
        var scrollPaneHeight = menuScrollPane.offsetHeight;
        var scrollTop = menuScrollPane.scrollTop;
        var maxAvailableScrollPaneHeight = viewportHeight - spaceAboveItems - spaceBelowItems - viewportGap * 2;
        var isScrollable = scrollPaneHeight < itemsHeight;
        var isNotUsingMaxAvailableHeight = scrollPaneHeight < maxAvailableScrollPaneHeight;
        // we need to expand the menu on scroll
        if (isScrollable && isNotUsingMaxAvailableHeight) {
            // expand from top to bottom
            if (Math.ceil(menuWrapperRect.top) === viewportGap) {
                var newHeight = itemsHeight - scrollTop;
                var newScrollPaneHeight = Math.min(newHeight, maxAvailableScrollPaneHeight);
                menuScrollPane.style.height = newScrollPaneHeight + 'px';
            }
            // expand from bottom to top
            if (Math.floor(menuWrapperRect.bottom) === viewportHeight - viewportGap) {
                var currentMenuY = Number((menuWrapper.style.top || '').replace('px', ''));
                var newHeight = scrollPaneHeight + scrollTop;
                var hasReachedMaxHeight = newHeight >= maxAvailableScrollPaneHeight;
                var newScrollPaneHeight = hasReachedMaxHeight ? maxAvailableScrollPaneHeight : newHeight;
                var maxHeightDiff = newHeight - newScrollPaneHeight;
                menuWrapper.style.top = currentMenuY - scrollTop + maxHeightDiff + 'px';
                menuScrollPane.style.height = newScrollPaneHeight + 'px';
                menuScrollPane.scrollTop = !maxAvailableScrollPaneHeight ? 0 : maxHeightDiff;
            }
        }
    }
    if (menuScrollPane) {
        // start listening to scroll
        menuScrollPane.addEventListener('scroll', handleMenuScroll);
        // return a function to stop listening to scroll
        return function stopExpandingMenuOnScroll() {
            menuScrollPane.removeEventListener('scroll', handleMenuScroll);
        };
    }
    return function () { };
}
function scrollMenuItemIntoView(_a) {
    var menuItem = _a.menuItem, menu = _a.menu, menuScrollPane = _a.menuScrollPane, scrollIndicator = _a.scrollIndicator;
    // we need a reference to these elements
    if (!menuItem || !menu || !menuScrollPane || !scrollIndicator) {
        return;
    }
    // MENU INFO
    //
    var menuStyles = getElementBoxModelStyles(menu);
    var scrollIndicatorHeight = scrollIndicator.offsetHeight;
    // MENU ITEM INFO
    //
    var menuItemHeight = menuItem.offsetHeight;
    // the reason this calculation works is because `menuItem.offsetTop`
    // is relative to the closest `position: relative|absolute` parent, in our case the menu.
    // however, it doesn't take into account the borderTop of the menu, so we only need to
    // subtract the padding top
    var distanceFromScrollPaneTopToMenuItemTop = menuItem.offsetTop - menuStyles.paddingTop;
    // SCROLL PANE INFO
    //
    var scrollPaneHeight = menuScrollPane.offsetHeight;
    var scrollTop = menuScrollPane.scrollTop;
    // we need to scroll towards the top
    var topCompensationDiff = menuStyles.paddingTop - scrollIndicatorHeight;
    var topScrollCompensation = topCompensationDiff >= 0 ? 0 : Math.abs(topCompensationDiff);
    var topScrollThreshold = distanceFromScrollPaneTopToMenuItemTop - topScrollCompensation;
    var isMenuItemPartiallyHiddenAtTop = scrollTop > topScrollThreshold;
    if (isMenuItemPartiallyHiddenAtTop) {
        menuScrollPane.scrollTop = topScrollThreshold;
    }
    // we need to scroll towards the bottom
    var bottomCompensationDiff = menuStyles.paddingBottom - scrollIndicatorHeight;
    var bottomScrollCompensation = bottomCompensationDiff >= 0 ? 0 : Math.abs(bottomCompensationDiff);
    var bottomScrollThreshold = distanceFromScrollPaneTopToMenuItemTop + menuItemHeight - scrollPaneHeight + bottomScrollCompensation;
    var isMenuItemPartiallyHiddenAtBottom = scrollTop < bottomScrollThreshold;
    if (isMenuItemPartiallyHiddenAtBottom) {
        menuScrollPane.scrollTop = bottomScrollThreshold;
    }
}

var REST_THRESHOLD_DURATION = 50;
var AUTOSCROLL_INTERVAL_DURATION = 50;
function useMenuScrollIndicators(_a) {
    var isOpen = _a.isOpen, scrollPaneRef = _a.scrollPaneRef, itemRef = _a.itemRef, topScrollIndicatorRef = _a.topScrollIndicatorRef, bottomScrollIndicatorRef = _a.bottomScrollIndicatorRef;
    React.useEffect(function () {
        var scrollPane = scrollPaneRef.current;
        var item = itemRef.current;
        var topScrollIndicator = topScrollIndicatorRef.current;
        var bottomScrollIndicator = bottomScrollIndicatorRef.current;
        function handleScroll() {
            if (!scrollPane || !topScrollIndicator || !bottomScrollIndicator) {
                return;
            }
            var isScrolledTop = scrollPane.scrollTop === 0;
            var isScrolledBottom = 
            // we use Math.ceil here because if the UI is zoomed-in
            // `scrollTop` is not always reported as an integer
            Math.ceil(scrollPane.scrollTop) >= scrollPane.scrollHeight - scrollPane.clientHeight;
            topScrollIndicator.style.opacity = isScrolledTop ? '0' : '1';
            topScrollIndicator.style.pointerEvents = isScrolledTop ? 'none' : 'auto';
            bottomScrollIndicator.style.opacity = isScrolledBottom ? '0' : '1';
            bottomScrollIndicator.style.pointerEvents = isScrolledBottom ? 'none' : 'auto';
        }
        var topRestTimerId;
        var topAutoScrollIntervalId;
        function handleTopScrollIndicatorMouseMove() {
            clearTimeout(topRestTimerId);
            topRestTimerId = window.setTimeout(autoScrollTop, REST_THRESHOLD_DURATION);
        }
        function autoScrollTop() {
            if (!scrollPane || !item || topAutoScrollIntervalId !== undefined) {
                return;
            }
            topAutoScrollIntervalId = window.setInterval(function () {
                scrollPane.scrollTop -= item.offsetHeight;
            }, AUTOSCROLL_INTERVAL_DURATION);
        }
        function handleTopScrollIndicatorMouseLeave() {
            clearTimeout(topRestTimerId);
            clearInterval(topAutoScrollIntervalId);
            topAutoScrollIntervalId = undefined;
        }
        var bottomRestTimerId;
        var bottomAutoScrollIntervalId;
        function handleBottomScrollIndicatorMouseMove() {
            clearTimeout(bottomRestTimerId);
            bottomRestTimerId = window.setTimeout(autoScrollBottom, REST_THRESHOLD_DURATION);
        }
        function autoScrollBottom() {
            if (!scrollPane || !item || bottomAutoScrollIntervalId !== undefined) {
                return;
            }
            bottomAutoScrollIntervalId = window.setInterval(function () {
                scrollPane.scrollTop += item.offsetHeight;
            }, AUTOSCROLL_INTERVAL_DURATION);
        }
        function handleBottomScrollIndicatorMouseLeave() {
            clearTimeout(bottomRestTimerId);
            clearInterval(bottomAutoScrollIntervalId);
            bottomAutoScrollIntervalId = undefined;
        }
        if (isOpen) {
            if (!scrollPane || !topScrollIndicator || !bottomScrollIndicator) {
                return function () { };
            }
            // kick-off so the indicators are initialized correctly
            handleScroll();
            scrollPane.addEventListener('scroll', handleScroll);
            topScrollIndicator.addEventListener('mousemove', handleTopScrollIndicatorMouseMove);
            topScrollIndicator.addEventListener('mouseleave', handleTopScrollIndicatorMouseLeave);
            bottomScrollIndicator.addEventListener('mousemove', handleBottomScrollIndicatorMouseMove);
            bottomScrollIndicator.addEventListener('mouseleave', handleBottomScrollIndicatorMouseLeave);
            return function () {
                scrollPane.removeEventListener('scroll', handleScroll);
                topScrollIndicator.removeEventListener('mousemove', handleTopScrollIndicatorMouseMove);
                topScrollIndicator.removeEventListener('mouseleave', handleTopScrollIndicatorMouseLeave);
                bottomScrollIndicator.removeEventListener('mousemove', handleBottomScrollIndicatorMouseMove);
                bottomScrollIndicator.removeEventListener('mouseleave', handleBottomScrollIndicatorMouseLeave);
            };
        }
    }, [isOpen, scrollPaneRef, itemRef, topScrollIndicatorRef, bottomScrollIndicatorRef]);
}

function canProcessTypeahead(event) {
    var isOneChar = event.key.length === 1;
    return isOneChar && !hasModifierKey(event);
}
/**
 * In a typeahead scenario (select, menu, …), this functions gets the item index to select next based on:
 * - all items available
 * - the currently selected index (if any)
 * - the current search buffer in use (ie. "unit" when searching for "United Kingdom")
 *
 * The behaviour it mimics is as follows:
 * - when typing the same letter in intervals, cycles through the items starting with this letter
 * - when typing a few letters in a row, attempt to match an item that starts with that buffer
 */
function getTypeaheadIndex(_a) {
    var items = _a.items, _b = _a.currentIndex, currentIndex = _b === void 0 ? getFirstSelectableIndex(items) : _b, searchBuffer = _a.searchBuffer;
    if (searchBuffer === undefined) {
        return currentIndex;
    }
    // these are the items that can actually be selected
    // no undefined, no disabled items
    var selectableItems = getSelectableItems(items);
    // because the typeahead matching takes into account the current index
    // we reorder the items by slicing at the current index and switching left and right side of the array
    // this way we can always pick the first item that matches
    var currentItem = currentIndex === undefined ? undefined : items[currentIndex];
    var currentSelectableIndex = currentItem ? selectableItems.indexOf(currentItem) : -1;
    var reorderedItems = changeArrayStartIndex(selectableItems, currentSelectableIndex);
    // if the buffer is just the same character repeated (ie. uuuuu)
    // we cycle through the items with labels which start with that given character
    // we start at the first match which exists below the `currentSelectableIndex`
    if (isRepeatedChar(searchBuffer)) {
        var firstBufferChar = searchBuffer[0];
        var matchingItems = getMatchingItems(reorderedItems, firstBufferChar);
        if (matchingItems.length > 0) {
            var matchingIndex = currentItem ? matchingItems.indexOf(currentItem) : -1;
            var nextIndex = (matchingIndex + 1) % matchingItems.length;
            var matchingItem = matchingItems[nextIndex];
            return items.indexOf(matchingItem);
        }
    }
    // else, we try and match an item based on the buffer
    // ie. a buffer of "fr" would match and select "France" in a country list
    else {
        var matchingItems = getMatchingItems(reorderedItems, searchBuffer);
        if (matchingItems.length > 0) {
            var matchingItem = matchingItems[0];
            return items.indexOf(matchingItem);
        }
    }
    // in all other case, we stay on the current item
    return currentIndex;
}
function hasModifierKey(event) {
    return event.shiftKey || event.ctrlKey || event.altKey || event.metaKey;
}
/**
 * Generates a new array where the start index is changed.
 * ie. changeArrayStartIndex(['a', 'b', 'c', 'd', 'e'], 3) => ['d', 'e', 'a', 'b', 'c']
 */
function changeArrayStartIndex(array, indexToPutFirst) {
    var start = array.slice(0, indexToPutFirst);
    var end = array.slice(indexToPutFirst, array.length);
    return end.concat(start);
}
/**
 * Returns whether a string is just the same character repeated all over
 * ie. eeeee or EEEEE but not eeeEEE
 */
function isRepeatedChar(value) {
    return value.length > 1 && Array.from(value).every(function (char, index, array) { return char === array[0]; });
}

function useControlledState(_a) {
    var prop = _a.prop, defaultProp = _a.defaultProp, onChange = _a.onChange, unstable__isControlled = _a.unstable__isControlled;
    var _b = React.useState(defaultProp), _state = _b[0], _setState = _b[1];
    var isControlled = unstable__isControlled !== undefined ? unstable__isControlled : prop !== undefined;
    var state = isControlled ? prop : _state;
    var isInitiallyControlledRef = React.useRef(isControlled);
    var initialValueRef = React.useRef(state);
    var setState = React.useCallback(function setState(state) {
        if (!isInitiallyControlledRef.current) {
            _setState(state);
        }
        onChange && onChange(state);
    }, [isInitiallyControlledRef, onChange]);
    var resetState = React.useCallback(function resetState() {
        setState(initialValueRef.current);
    }, [setState]);
    return [state, setState, resetState];
}

function useScrollbarWidth() {
    var _a = React.useState(getScrollbarWidth()), sidebarWidth = _a[0], setSidebarWidth = _a[1];
    // try to calculate it again in the next frame in case we don't have it
    React.useEffect(function () {
        if (sidebarWidth !== undefined) {
            return;
        }
        var raf = requestAnimationFrame(function () {
            setSidebarWidth(getScrollbarWidth());
        });
        return function () { return cancelAnimationFrame(raf); };
    }, [sidebarWidth]);
    return sidebarWidth;
}
var SCROLLBAR_WIDTH_CACHE;
var SCROLLBAR_TEST_ELEMENT_SIZE = 100;
var getScrollbarWidth = function () {
    // bail out of ssr
    if (typeof document === 'undefined') {
        return 0;
    }
    // if DOM isn't ready
    if (!document.body || (document.readyState && document.readyState === 'loading')) {
        return undefined;
    }
    // return cache if available
    if (SCROLLBAR_WIDTH_CACHE !== undefined) {
        return SCROLLBAR_WIDTH_CACHE;
    }
    var element = document.createElement('div');
    element.style.display = 'block';
    element.style.width = SCROLLBAR_TEST_ELEMENT_SIZE + "px";
    element.style.height = SCROLLBAR_TEST_ELEMENT_SIZE + "px";
    element.style.position = 'absolute';
    element.style.top = '-9999px';
    element.style.left = '-9999px';
    element.style.overflow = 'scroll';
    document.body.insertBefore(element, null);
    var clientWidth = element.clientWidth;
    // bail out and clean up if DOM isn't ready
    if (clientWidth === 0) {
        document.body.removeChild(element);
        return undefined;
    }
    SCROLLBAR_WIDTH_CACHE = SCROLLBAR_TEST_ELEMENT_SIZE - clientWidth;
    document.body.removeChild(element);
    return SCROLLBAR_WIDTH_CACHE;
};

var MenuContext = React.createContext({
    menuId: '',
    itemsCount: 0,
    setHighlightedIndex: function () { },
});
var MenuStylingContext = React.createContext({});
var SCROLLBAR_MASK_OFFSET = 20;
var Menu = React.forwardRef(function (props, forwardedRef) {
    var children = props.children, id = props.id, _a = props.role, role = _a === void 0 ? 'menu' : _a, buttonRef = props.buttonRef, buttonTextRef = props.buttonTextRef, anchorPoint = props.anchorPoint, isOpenProp = props.isOpen, onClose = props.onClose, refToFocusOnClose = props.refToFocusOnClose, highlightedIndexProp = props.highlightedIndex, onHighlightedIndexChange = props.onHighlightedIndexChange, defaultHighlightedIndex = props.defaultHighlightedIndex, onItemSelected = props.onItemSelected, _b = props.calculateMenuPosition, calculateMenuPosition$1 = _b === void 0 ? calculateMenuPosition : _b, styleConfig = props.styleConfig, menuProps = __rest(props, ["children", "id", "role", "buttonRef", "buttonTextRef", "anchorPoint", "isOpen", "onClose", "refToFocusOnClose", "highlightedIndex", "onHighlightedIndexChange", "defaultHighlightedIndex", "onItemSelected", "calculateMenuPosition", "styleConfig"]);
    var debugContext = useDebugContext();
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var menuStyles = getPartStyles('menu', styleConfig, variantsMap);
    var scrollIndicatorStyles = getPartStyles('scrollIndicator', styleConfig, variantsMap);
    var itemStyles = getPartStyles('item', styleConfig, variantsMap);
    var itemIconStyles = getPartStyles('itemIcon', styleConfig, variantsMap);
    var labelStyles = getPartStyles('label', styleConfig, variantsMap);
    var separatorStyles = getPartStyles('separator', styleConfig, variantsMap);
    var _c = getItems(children), items = _c.items, allowedChildren = _c.allowedChildren;
    var generatedMenuId = "menu-" + useId();
    var menuId = id || generatedMenuId;
    var isOpen = Boolean(isOpenProp);
    var prevIsOpen = usePrevious(isOpen);
    var _d = useControlledState({
        prop: highlightedIndexProp,
        defaultProp: defaultHighlightedIndex,
        onChange: onHighlightedIndexChange,
    }), highlightedIndex = _d[0], setHighlightedIndex = _d[1], resetHighlightedIndex = _d[2];
    var _e = useSelfResettingState(), typeaheadBuffer = _e[0], setTypeaheadBuffer = _e[1];
    var scrollbarWidth = useScrollbarWidth();
    var hasFloatingScrollbar = scrollbarWidth === undefined || scrollbarWidth === 0;
    // setup all necesarry refs to elements
    var menuWrapperRef = React.useRef(null);
    var menuRef = React.useRef(null);
    var menuScrollPaneRef = React.useRef(null);
    var menuItemsWrapperRef = React.useRef(null);
    var menuItemRef = React.useRef(null);
    var referenceItemRef = React.useRef(null);
    var referenceItemTextRef = React.useRef(null);
    var topMenuScrollIndicatorRef = React.useRef(null);
    var bottomMenuScrollIndicatorRef = React.useRef(null);
    var composedMenuRef = useComposedRefs(forwardedRef, menuRef);
    var scrollToItem = React.useCallback(function (index) {
        var item = index !== undefined ? items[index] : undefined;
        var menuItem = item && item.ref ? item.ref.current : null;
        scrollMenuItemIntoView({
            menuItem: menuItem,
            menu: menuRef.current,
            menuScrollPane: menuScrollPaneRef.current,
            scrollIndicator: topMenuScrollIndicatorRef.current,
        });
    }, [items]);
    /**
     * Sets the highlighted index and scrolls the menu
     * to make sure the associated menu item is always visible in view.
     * This method should be used when setting the highlighted index via keyboard.
     */
    function setHighlightedIndexViaKeyboard(index) {
        setHighlightedIndex(index);
        scrollToItem(index);
    }
    /**
     * Selects an item by index, finds its DOM element and fires a click event on it.
     * This then goes into the same flow as if the user had clicked on the item.
     */
    function selectItem(index) {
        var selectedItem = index !== undefined ? items[index] : undefined;
        var selectedMenuItem = selectedItem && selectedItem.ref ? selectedItem.ref.current : null;
        if (selectedMenuItem) {
            selectedMenuItem.click();
        }
    }
    // whenever the menu opens:
    // - positions the menu in the right place and size it accordingly
    // - starts listening to scroll on the menu to update its height accordingly
    React.useEffect(function () {
        var _a, _b;
        var anchorRect;
        // we have a button we're anchoring to (ie. menu button use cases)
        if (buttonRef && buttonRef.current) {
            anchorRect = getRoundedRect(buttonRef.current);
        }
        // we have a point we're anchoring to (ie. context menu use cases)
        else if (anchorPoint) {
            anchorRect = makeRect({ width: 0, height: 0 }, anchorPoint);
        }
        var anchorText = buttonTextRef ? buttonTextRef.current : undefined;
        var menuWrapper = menuWrapperRef.current;
        var menu = menuRef.current;
        var menuScrollPane = menuScrollPaneRef.current;
        var menuItemsWrapper = menuItemsWrapperRef.current;
        var scrollIndicator = topMenuScrollIndicatorRef.current;
        var referenceItem = referenceItemRef.current;
        var referenceItemText = referenceItemTextRef.current;
        if (isOpen) {
            var menuPosition = calculateMenuPosition$1({
                anchorRect: anchorRect,
                anchorText: anchorText,
                menuWrapper: menuWrapper,
                menu: menu,
                menuItemsWrapper: menuItemsWrapper,
                scrollIndicator: scrollIndicator,
                referenceItem: referenceItem,
                referenceItemText: referenceItemText,
                viewportGap: (_a = debugContext.viewportGap) !== null && _a !== void 0 ? _a : DEFAULT_VIEWPORT_GAP,
            });
            if (menuWrapper && menuScrollPane && menuPosition) {
                setMenuPosition({ menuWrapper: menuWrapper, menuScrollPane: menuScrollPane, menuPosition: menuPosition });
            }
            var stopExpandingMenuOnScroll = startExpandingMenuOnScroll({
                menuWrapper: menuWrapperRef.current,
                menu: menuRef.current,
                menuScrollPane: menuScrollPaneRef.current,
                menuItemsWrapper: menuItemsWrapperRef.current,
                viewportGap: (_b = debugContext.viewportGap) !== null && _b !== void 0 ? _b : DEFAULT_VIEWPORT_GAP,
            });
            // to clean-up our effect, we want to stop listening to scroll
            return stopExpandingMenuOnScroll;
        }
    }, [isOpen, buttonRef, anchorPoint, calculateMenuPosition$1, buttonTextRef, debugContext.viewportGap]);
    useMenuScrollIndicators({
        isOpen: isOpen,
        scrollPaneRef: menuScrollPaneRef,
        itemRef: menuItemRef,
        topScrollIndicatorRef: topMenuScrollIndicatorRef,
        bottomScrollIndicatorRef: bottomMenuScrollIndicatorRef,
    });
    // whenever the menu closes:
    // - reset the highlighted index
    // - reset the typeahead buffer
    React.useEffect(function () {
        if (isOpen === false) {
            resetHighlightedIndex();
            setTypeaheadBuffer(undefined);
        }
    }, [isOpen, resetHighlightedIndex, setTypeaheadBuffer]);
    // whenever the menu opens:
    // - scroll to highlighted item
    React.useEffect(function () {
        var hasOpened = !prevIsOpen && isOpen;
        if (hasOpened) {
            scrollToItem(highlightedIndex);
        }
    }, [prevIsOpen, isOpen, scrollToItem, highlightedIndex]);
    // whenever the window gets blurred/resized:
    // - close the menu
    React.useEffect(function () {
        function closeMenu() {
            onClose && onClose();
        }
        if (isOpen) {
            window.addEventListener('blur', closeMenu);
            window.addEventListener('resize', closeMenu);
            return function () {
                window.removeEventListener('blur', closeMenu);
                window.removeEventListener('resize', closeMenu);
            };
        }
    }, [isOpen, onClose]);
    return (React.createElement(MenuContext.Provider, { value: {
            menuId: menuId,
            itemsCount: items.length,
            highlightedIndex: highlightedIndex,
            setHighlightedIndex: setHighlightedIndex,
            onItemSelected: onItemSelected,
            onClose: onClose,
            menuItemRef: menuItemRef,
            referenceItemRef: referenceItemRef,
            referenceItemTextRef: referenceItemTextRef,
        } },
        React.createElement(MenuStylingContext.Provider, { value: { itemStyles: itemStyles, itemIconStyles: itemIconStyles, labelStyles: labelStyles, separatorStyles: separatorStyles } }, isOpen && (React.createElement(Portal, null,
            React.createElement(Lock, { isActive: debugContext.disableLock ? false : isOpen, onDeactivate: onClose, refToFocusOnDeactivation: buttonRef || refToFocusOnClose, shouldDeactivateOnEscape: true, shouldDeactivateOnOutsideClick: true, shouldBlockOutsideClick: true, shouldLockScroll: true },
                React.createElement("div", { ref: menuWrapperRef, style: { position: 'absolute' } },
                    React.createElement(MenuPart, __assign({}, menuProps, { 
                        // accessibility
                        id: menuId, role: role, "aria-activedescendant": highlightedIndex !== undefined ? makeItemId(menuId, highlightedIndex) : undefined, 
                        // to enable focus
                        tabIndex: 0, onKeyDown: function (event) {
                            // to make sure we  don't also trigger top-level shortcuts for example
                            event.stopPropagation();
                            if (canProcessTypeahead(event)) {
                                event.preventDefault();
                                var isBuffering = typeaheadBuffer !== undefined;
                                if (event.key === ' ' && !isBuffering) {
                                    selectItem(highlightedIndex);
                                }
                                else {
                                    var updatedBuffer = (typeaheadBuffer || '') + event.key;
                                    setTypeaheadBuffer(updatedBuffer);
                                    var typeaheadIndex = getTypeaheadIndex({
                                        items: items,
                                        currentIndex: highlightedIndex,
                                        searchBuffer: updatedBuffer,
                                    });
                                    setHighlightedIndexViaKeyboard(typeaheadIndex);
                                }
                            }
                            switch (event.key) {
                                case 'ArrowUp':
                                case 'ArrowDown':
                                    event.preventDefault();
                                    setHighlightedIndexViaKeyboard(getNextSelectableIndex({
                                        items: items,
                                        currentIndex: highlightedIndex,
                                        key: event.key,
                                    }));
                                    break;
                                case 'Enter':
                                    event.preventDefault();
                                    selectItem(highlightedIndex);
                                    break;
                                case 'Home':
                                case 'PageUp':
                                    event.preventDefault();
                                    setHighlightedIndexViaKeyboard(getFirstSelectableIndex(items));
                                    break;
                                case 'End':
                                case 'PageDown':
                                    event.preventDefault();
                                    setHighlightedIndexViaKeyboard(getLastSelectableIndex(items));
                                    break;
                            }
                        }, 
                        // other props
                        ref: composedMenuRef, menuStyles: menuStyles, onMouseLeave: function () { return setHighlightedIndex(undefined); } }),
                        React.createElement(ScrollIndicatorPart, { ref: topMenuScrollIndicatorRef, scrollIndicatorStyles: scrollIndicatorStyles, style: { top: 0, transform: 'rotate(180deg)' }, onMouseMove: function () { return setHighlightedIndex(undefined); } },
                            React.createElement(Arrow, { fill: "currentColor" })),
                        React.createElement(ScrollIndicatorPart, { ref: bottomMenuScrollIndicatorRef, scrollIndicatorStyles: scrollIndicatorStyles, style: { bottom: 0 }, onMouseMove: function () { return setHighlightedIndex(undefined); } },
                            React.createElement(Arrow, { fill: "currentColor" })),
                        React.createElement("div", { ref: menuScrollPaneRef, style: {
                                boxSizing: 'border-box',
                                width: hasFloatingScrollbar
                                    ? "calc(100% + " + SCROLLBAR_MASK_OFFSET + "px)"
                                    : "calc(100% + " + scrollbarWidth + "px)",
                                overflowX: 'hidden',
                                overflowY: 'auto',
                                WebkitOverflowScrolling: 'touch',
                            } },
                            React.createElement("div", { ref: menuItemsWrapperRef, style: {
                                    width: hasFloatingScrollbar ? "calc(100% - " + SCROLLBAR_MASK_OFFSET + "px)" : undefined,
                                } }, allowedChildren))))))))));
});
Menu.displayName = 'Menu';
var MenuItem = React.forwardRef(function MenuItem(_a, forwardedRef) {
    var label = _a.label, value = _a.value, disabled = _a.disabled, grouped = _a.grouped, selected = _a.selected, onSelect = _a.onSelect, _b = _a.role, role = _b === void 0 ? 'menuitem' : _b, _c = _a.index, index = _c === void 0 ? -1 : _c, isReference = _a.isReference, props = __rest(_a, ["label", "value", "disabled", "grouped", "selected", "onSelect", "role", "index", "isReference"]);
    var _d = React.useContext(MenuContext), menuId = _d.menuId, itemsCount = _d.itemsCount, highlightedIndex = _d.highlightedIndex, setHighlightedIndex = _d.setHighlightedIndex, onItemSelected = _d.onItemSelected, onClose = _d.onClose, menuItemRef = _d.menuItemRef, referenceItemRef = _d.referenceItemRef, referenceItemTextRef = _d.referenceItemTextRef;
    var id = makeItemId(menuId, index);
    var isHighlighted = index === highlightedIndex;
    var isDisabled = Boolean(disabled);
    var isGrouped = Boolean(grouped);
    var isSelected = Boolean(selected);
    var _e = React.useContext(MenuStylingContext), itemStyles = _e.itemStyles, itemIconStyles = _e.itemIconStyles;
    var ref = React.useRef(null);
    var composedMenuItemRef = useComposedRefs(forwardedRef, ref, menuItemRef, isReference || index === 0 ? referenceItemRef : undefined);
    var highlightItem = React.useCallback(function highlightItem() {
        setHighlightedIndex(isDisabled ? undefined : index);
    }, [index, isDisabled, setHighlightedIndex]);
    var item = React.useMemo(function () { return getItemFromMenuItemProps({ label: label, value: value, disabled: disabled, ref: ref }); }, [disabled, label, value]);
    var selectItem = React.useCallback(function selectItem() {
        if (!isDisabled) {
            onSelect && onSelect();
            onClose && onClose();
            onItemSelected && onItemSelected(item);
        }
    }, [isDisabled, item, onClose, onItemSelected, onSelect]);
    return (React.createElement(MenuItemImpl
    // accessibility
    , __assign({ 
        // accessibility
        id: id, role: role, "aria-disabled": isDisabled ? true : undefined, "aria-setsize": itemsCount, "aria-posinset": index + 1 }, props, { ref: composedMenuItemRef, onMouseMove: highlightItem, onClick: selectItem, 
        // extra props
        label: label, labelRef: isReference ? referenceItemTextRef : undefined, isHighlighted: isHighlighted, isDisabled: isDisabled, isGrouped: isGrouped, isSelected: isSelected, itemStyles: itemStyles, iconStyles: itemIconStyles })));
});
MenuItem.displayName = 'MenuItem';
var MenuItemImpl = React.memo(React.forwardRef(function MenuItemImpl(_a, forwardedRef) {
    var label = _a.label, labelRef = _a.labelRef, isHighlighted = _a.isHighlighted, isDisabled = _a.isDisabled, isGrouped = _a.isGrouped, isSelected = _a.isSelected, itemStyles = _a.itemStyles, iconStyles = _a.iconStyles, props = __rest(_a, ["label", "labelRef", "isHighlighted", "isDisabled", "isGrouped", "isSelected", "itemStyles", "iconStyles"]);
    return (React.createElement(MenuItemPart, __assign({}, props, { ref: forwardedRef, isHighlighted: isHighlighted, isDisabled: isDisabled, isGrouped: isGrouped, 
        // style props
        menuItemStyles: itemStyles }),
        isSelected && (React.createElement(MenuItemIconPart, { menuItemIconStyles: iconStyles },
            React.createElement(radixIcons.CheckIcon, { size: "15", style: { display: 'block' } }))),
        React.createElement("span", { ref: labelRef }, label)));
}));
MenuItemImpl.displayName = 'MenuItemImpl';
var MenuItemCheckbox = React.forwardRef(function MenuItemCheckbox(_a, forwardedRef) {
    var checkedProp = _a.checked, onChange = _a.onChange, defaultChecked = _a.defaultChecked, props = __rest(_a, ["checked", "onChange", "defaultChecked"]);
    var _b = useControlledState({
        prop: checkedProp,
        defaultProp: defaultChecked,
        onChange: onChange,
    }), checked = _b[0], setChecked = _b[1];
    return (React.createElement(MenuItem, __assign({}, props, { ref: forwardedRef, role: "menuitemcheckbox", selected: checked, onSelect: function () { return setChecked(checked === true ? false : true); } })));
});
MenuItemCheckbox.displayName = 'MenuItemCheckbox';
var MenuItemRadioGroupContext = React.createContext({
    setValue: function () { },
});
function MenuItemRadioGroup(_a) {
    var children = _a.children, valueProp = _a.value, onChange = _a.onChange, defaultValue = _a.defaultValue;
    var _b = useControlledState({
        prop: valueProp,
        defaultProp: defaultValue,
        onChange: onChange,
    }), value = _b[0], setValue = _b[1];
    return (React.createElement(MenuItemRadioGroupContext.Provider, { value: { value: value, setValue: setValue } }, children));
}
var MenuItemRadio = React.forwardRef(function MenuItemRadio(_a, forwardedRef) {
    var menuItemRadioValue = _a.value, props = __rest(_a, ["value"]);
    var _b = React.useContext(MenuItemRadioGroupContext), value = _b.value, setValue = _b.setValue;
    var isSelected = menuItemRadioValue === value;
    return (React.createElement(MenuItem, __assign({}, props, { ref: forwardedRef, role: "menuitemradio", selected: isSelected, onSelect: function () { return setValue(menuItemRadioValue); } })));
});
MenuItemRadio.displayName = 'MenuItemRadio';
function MenuItemLabel(_a) {
    var children = _a.children;
    var setHighlightedIndex = React.useContext(MenuContext).setHighlightedIndex;
    var labelStyles = React.useContext(MenuStylingContext).labelStyles;
    return (React.createElement(MenuItemLabelPart, { menuItemLabelStyles: labelStyles, onMouseMove: function () { return setHighlightedIndex(undefined); } }, children));
}
function MenuItemSeparator(props) {
    var separatorStyles = React.useContext(MenuStylingContext).separatorStyles;
    return (React.createElement(MenuItemSeparatorPart, { role: "separator", "aria-orientation": "horizontal", menuItemSeparatorStyles: separatorStyles }));
}
var MenuPart = styled('div').attrs({ 'data-part-id': 'menu' })(
// reset styles
cssReset('div'), 
// functional styles
{
    // `position: relative` is important because it's the only way
    // for the `overflow: hidden` to work properly over absolutely positioned
    // elements inside the Menu (like the scroll indicators)
    position: 'relative',
    overflow: 'hidden',
    outline: 'none',
}, 
// apply style config
function (_a) {
    var _b = _a.menuStyles, menuStyles = _b === void 0 ? {} : _b;
    return menuStyles.normal;
}, 
// add system support
boxSystemProps);
MenuPart.displayName = 'MenuPart';
var ScrollIndicatorPart = styled('div').attrs({ 'data-part-id': 'scrollIndicator' })(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
    position: 'absolute',
    left: 0,
    zIndex: 1,
}, 
// apply style config
function (_a) {
    var _b = _a.scrollIndicatorStyles, scrollIndicatorStyles = _b === void 0 ? {} : _b;
    var normal = scrollIndicatorStyles.normal, hover = scrollIndicatorStyles.hover;
    return __assign(__assign({}, normal), { '&:hover': hover });
});
ScrollIndicatorPart.displayName = 'ScrollIndicatorPart';
var MenuItemPart = styled('div').attrs({ 'data-part-id': 'item' })(
// reset styles
cssReset('div'), 
// functional styles
{
    // `position: relative` is important because we use it to calculate
    // the text offset left to contribute to the horizontal alignment of the menu
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    lineHeight: '1',
    cursor: 'default',
    userSelect: 'none',
    whiteSpace: 'nowrap',
}, 
// apply style config
function (_a) {
    var _b = _a.menuItemStyles, menuItemStyles = _b === void 0 ? {} : _b, isHighlighted = _a.isHighlighted, isDisabled = _a.isDisabled, isGrouped = _a.isGrouped;
    var normal = menuItemStyles.normal, highlighted = menuItemStyles.highlighted, grouped = menuItemStyles.grouped, disabled = menuItemStyles.disabled;
    return __assign(__assign(__assign(__assign({}, normal), (isHighlighted ? highlighted : {})), (isGrouped ? grouped : {})), (isDisabled ? disabled : {}));
});
MenuItemPart.displayName = 'MenuItemPart';
var MenuItemIconPart = styled('span').attrs({
    'data-part-id': 'itemIcon',
})(
// reset styles
cssReset('span'), 
// functional styles
{
    position: 'absolute',
    top: 0,
    left: 0,
    display: 'inline-flex',
    height: '100%',
    alignItems: 'center',
}, 
// apply style config
function (_a) {
    var _b = _a.menuItemIconStyles, menuItemIconStyles = _b === void 0 ? {} : _b;
    return menuItemIconStyles.normal;
});
MenuItemIconPart.displayName = 'MenuItemIconPart';
var MenuItemLabelPart = styled('div').attrs({ 'data-part-id': 'label' })(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'flex',
    alignItems: 'center',
    lineHeight: '1',
    cursor: 'default',
    userSelect: 'none',
    whiteSpace: 'nowrap',
}, 
// apply style config
function (_a) {
    var _b = _a.menuItemLabelStyles, menuItemLabelStyles = _b === void 0 ? {} : _b;
    return menuItemLabelStyles.normal;
});
MenuItemLabelPart.displayName = 'MenuItemLabelPart';
var MenuItemSeparatorPart = styled('div').attrs({
    'data-part-id': 'separator',
})(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b = _a.menuItemSeparatorStyles, menuItemSeparatorStyles = _b === void 0 ? {} : _b;
    return menuItemSeparatorStyles.normal;
});
MenuItemSeparatorPart.displayName = 'MenuItemSeparatorPart';
/**
 * Extracts a useful datastructure of items from the react children,
 * as well as filters unwanted children
 */
function getItems(children) {
    var index = -1;
    var items = [];
    function getChild(child) {
        if (!React.isValidElement(child))
            return;
        if (child.type === MenuItemRadioGroup) {
            var menuItemRadioGroup = child;
            return (React.createElement(MenuItemRadioGroup, __assign({}, menuItemRadioGroup.props), React.Children.map(menuItemRadioGroup.props.children, getChild)));
        }
        if (child.type === MenuItem || child.type === MenuItemCheckbox || child.type === MenuItemRadio) {
            index++;
            var menuItem = child;
            var ref = React.createRef();
            var item = getItemFromMenuItemProps(__assign(__assign({}, menuItem.props), { ref: ref }));
            items.push(item);
            return React.cloneElement(menuItem, { index: index, ref: ref });
        }
        if (child.type === MenuItemLabel || child.type === MenuItemSeparator) {
            return child;
        }
    }
    // we use `Children.map` as a looping mechanism here so React preserves its keys logic
    var allowedChildren = React.Children.map(children, function (child) {
        // support Fragments
        if (ReactIs.isFragment(child)) {
            // we use `Children.map` as a looping mechanism here so React preserves its keys logic
            return React.Children.map(child.props.children, getChild);
        }
        return getChild(child);
    });
    return { items: items, allowedChildren: allowedChildren };
}
function getItemFromMenuItemProps(_a) {
    var label = _a.label, value = _a.value, disabled = _a.disabled, ref = _a.ref;
    return { label: label, value: value, isDisabled: Boolean(disabled), ref: ref };
}
function makeItemId(menuId, index) {
    return menuId + "-item-" + index;
}

var systemProps$j = boxSystemProps;
var Pipe = React.forwardRef(function Pipe(props, forwardedRef) {
    var styleConfig = props.styleConfig, pipeProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var pipeStyles = getPartStyles('pipe', styleConfig, variantsMap);
    return React.createElement(PipePart, __assign({}, pipeProps, { ref: forwardedRef, pipeStyles: pipeStyles }));
});
Pipe.displayName = 'Pipe';
var PipePart = styled('div').attrs({ 'data-part-id': 'pipe' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b = _a.pipeStyles, pipeStyles = _b === void 0 ? {} : _b;
    return pipeStyles.normal;
}, 
// add system support
systemProps$j);
PipePart.displayName = 'PipePart';

/**
 * Observes an element's rectangle on screen (getBoundingClientRect)
 * This is useful to track elements on the screen and attach other elements
 * that might be in different layers, etc.
 */
function observeElementRect(
/** The element whose rect to observe */
elementToObserve, 
/** The callback which will be called when the rect changes */
callback) {
    var observedData = observedElements.get(elementToObserve);
    if (observedData === undefined) {
        // add the element to the map of observed elements with its first callback
        // because this is the first time this element is observed
        observedElements.set(elementToObserve, { rect: {}, callbacks: [callback] });
        if (observedElements.size === 1) {
            // start the internal loop once at least 1 element is observed
            runLoop();
        }
    }
    else {
        // only add a callback for this element as it's already observed
        observedData.callbacks.push(callback);
    }
    return function () {
        var observedData = observedElements.get(elementToObserve);
        if (observedData === undefined)
            return;
        // start by removing the callback
        var index = observedData.callbacks.indexOf(callback);
        if (index > -1) {
            observedData.callbacks.splice(index, 1);
        }
        if (observedData.callbacks.length === 0) {
            // stop observing this element because there are no
            // callbacks registered for it anymore
            observedElements.delete(elementToObserve);
            if (observedElements.size === 0) {
                // stop the internal loop once no elements are observed anymore
                cancelAnimationFrame(rafId);
            }
        }
    };
}
var rafId;
var observedElements = new Map();
function runLoop() {
    var changedRectsData = [];
    // process all DOM reads first (getBoundingClientRect)
    observedElements.forEach(function (data, element) {
        var newRect = element.getBoundingClientRect();
        // gather all the data for elements whose rects have changed
        if (!rectEquals(data.rect, newRect)) {
            data.rect = newRect;
            changedRectsData.push(data);
        }
    });
    // group DOM writes here after the DOM reads (getBoundingClientRect)
    // as DOM writes will most likely happen with the callbacks
    changedRectsData.forEach(function (data) {
        data.callbacks.forEach(function (callback) { return callback(data.rect); });
    });
    rafId = requestAnimationFrame(runLoop);
}
// ========================================================================

/**
 * A version of `React.useLayoutEffect` which falls back to `React.useEffect`
 * on the server as `React.useLayoutEffect` does nothing on the server.
 */
var useIsomorphicLayoutEffect = typeof window === 'undefined' || typeof document === 'undefined' ? React.useEffect : React.useLayoutEffect;

/**
 * Use this custom hook to get access to an element's rect (getBoundingClientRect)
 * and observe it along time.
 */
function useRect(_a) {
    var refToObserve = _a.refToObserve, _b = _a.isObserving, isObserving = _b === void 0 ? true : _b, _c = _a.shouldResetWhenNotObserving, shouldResetWhenNotObserving = _c === void 0 ? false : _c;
    var _d = React.useState(), rect = _d[0], setRect = _d[1];
    useIsomorphicLayoutEffect(function () {
        if (isObserving && refToObserve.current) {
            var unobserve_1 = observeElementRect(refToObserve.current, setRect);
            return function () {
                if (shouldResetWhenNotObserving) {
                    setRect(undefined);
                }
                unobserve_1();
            };
        }
    }, [isObserving, refToObserve, shouldResetWhenNotObserving]);
    return rect;
}

function useSize(_a) {
    var refToObserve = _a.refToObserve, isObserving = _a.isObserving;
    var _b = React.useState(undefined), size = _b[0], setSize = _b[1];
    React.useEffect(function () {
        if (isObserving && refToObserve.current) {
            var elementToObserver_1 = refToObserve.current;
            var resizeObserver_1 = new ResizeObserver(function (entries) {
                if (!Array.isArray(entries)) {
                    return;
                }
                // Since we only observe the one element, we don't need to loop over the
                // array
                if (!entries.length) {
                    return;
                }
                var entry = entries[0];
                setSize({
                    width: entry.contentRect.width,
                    height: entry.contentRect.height,
                });
            });
            resizeObserver_1.observe(elementToObserver_1);
            return function () { return resizeObserver_1.unobserve(elementToObserver_1); };
        }
    }, [isObserving, refToObserve]);
    return size;
}

/**
 * Gets collisions for each side of a rect (top, right, bottom, left)
 */
function getCollisions(
/** The rect to test collisions against */
rect, 
/** An optional tolerance if you want the collisions to trigger a bit before/after */
tolerance) {
    if (tolerance === void 0) { tolerance = 0; }
    return {
        top: rect.top < tolerance,
        right: rect.right > window.innerWidth - tolerance,
        bottom: rect.bottom > window.innerHeight - tolerance,
        left: rect.left < tolerance,
    };
}

/**
 * Computes the styles necessary to position, rotate and align the arrow correctly.
 * It can adjust itself based on target/popper size, side/align and an optional offset.
 */
function getPopperArrowStyles(_a) {
    var _b;
    var popperSize = _a.popperSize, arrowSize = _a.arrowSize, arrowOffset = _a.arrowOffset, side = _a.side, align = _a.align;
    var popperCenterX = (popperSize.width - arrowSize.width) / 2;
    var popperCenterY = (popperSize.height - arrowSize.width) / 2;
    var rotationMap = { top: 0, right: 90, bottom: 180, left: -90 };
    var rotation = rotationMap[side];
    var arrowMaxDimension = Math.max(arrowSize.width, arrowSize.height);
    var styles = (_b = {
            // we make sure we put the arrow inside a 1:1 ratio container
            // this is to make the rotation handling simpler
            // as we do no need to worry about changing the transform-origin
            width: arrowMaxDimension + "px",
            height: arrowMaxDimension + "px",
            // rotate the arrow appropriately
            transform: "rotate(" + rotation + "deg)",
            willChange: 'transform',
            // position the arrow appropriately
            position: 'absolute'
        },
        _b[side] = '100%',
        // Because the arrow gets rotated (see `transform above`)
        // and we are putting it inside a 1:1 ratio container
        // we need to adjust the CSS direction from `ltr` to `rtl`
        // in some circumstances
        _b.direction = getArrowCssDirection(side, align),
        _b);
    if (side === 'top' || side === 'bottom') {
        if (align === 'start') {
            styles.left = arrowOffset + "px";
        }
        if (align === 'center') {
            styles.left = popperCenterX + "px";
        }
        if (align === 'end') {
            styles.right = arrowOffset + "px";
        }
    }
    if (side === 'left' || side === 'right') {
        if (align === 'start') {
            styles.top = arrowOffset + "px";
        }
        if (align === 'center') {
            styles.top = popperCenterY + "px";
        }
        if (align === 'end') {
            styles.bottom = arrowOffset + "px";
        }
    }
    return styles;
}
/**
 * Adjusts the arrow's CSS direction (`ltr` / `rtl`)
 */
function getArrowCssDirection(side, align) {
    if ((side === 'top' || side === 'right') && align === 'end') {
        return 'rtl';
    }
    if ((side === 'bottom' || side === 'left') && align !== 'end') {
        return 'rtl';
    }
    return 'ltr';
}

/**
 * Given all the information necessary to compute it,
 * this function calculates all the necessary placement data.
 *
 * It will return:
 *
 * - the styles to apply to the popper
 * - the styles to apply to the arrow
 * - some styles that could be useful to set the transform origin in the right place
 * - the adjusted side (because it might have changed because of collisions)
 * - the adjusted align (because it might have changed because of collisions)
 */
function getPlacementData(_a) {
    var targetRect = _a.targetRect, popperSize = _a.popperSize, arrowSize = _a.arrowSize, _b = _a.arrowOffset, arrowOffset = _b === void 0 ? 20 : _b, side = _a.side, _c = _a.sideOffset, sideOffset = _c === void 0 ? 0 : _c, align = _a.align, _d = _a.alignOffset, alignOffset = _d === void 0 ? 0 : _d, _e = _a.shouldAvoidCollisions, shouldAvoidCollisions = _e === void 0 ? true : _e, _f = _a.collisionTolerance, collisionTolerance = _f === void 0 ? 0 : _f;
    // if we're not ready to do all the measurements yet,
    // we return some good default styles
    if (!targetRect || !popperSize) {
        return {
            // position: 'fixed' here is important because it will take the popper
            // out of the flow so it does not disturb the position of the target
            popperStyles: {
                position: 'fixed',
                top: 0,
                left: 0,
                opacity: 0,
                pointerEvents: 'none',
            },
            arrowStyles: { opacity: 0 },
            transformOriginStyles: {},
            adjustedSide: side,
            adjustedAlign: align,
        };
    }
    // pre-compute points for all potential placements
    var allPlacementPoints = getAllPlacementPoints(popperSize, targetRect, sideOffset, alignOffset, arrowSize);
    // get point based on side / align
    var popperPoint = allPlacementPoints[side][align];
    // if we don't need to avoid collisions, we can stop here
    if (shouldAvoidCollisions === false) {
        var popperStyles_1 = getPlacementStylesForPoint(popperPoint);
        var arrowStyles_1 = {};
        if (arrowSize) {
            arrowStyles_1 = getPopperArrowStyles({ popperSize: popperSize, arrowSize: arrowSize, arrowOffset: arrowOffset, side: side, align: align });
        }
        var transformOriginStyles_1 = getTransformOriginStyles(popperSize, side, align, arrowOffset, arrowSize);
        return {
            popperStyles: popperStyles_1,
            arrowStyles: arrowStyles_1,
            transformOriginStyles: transformOriginStyles_1,
            adjustedSide: side,
            adjustedAlign: align,
        };
    }
    // create a new rect as if element had been moved to new placement
    var popperRect = makeRect(popperSize, popperPoint);
    // check for any collisions in new placement
    var popperCollisions = getCollisions(popperRect, collisionTolerance);
    // do all the same calculations for the opposite side
    // this is because we need to check for potential collisions if we were to swap side
    var oppositeSide = getOppositeSide(side);
    var oppositeSidePopperPoint = allPlacementPoints[oppositeSide][align];
    var updatedOppositeSidePopperPoint = makeRect(popperSize, oppositeSidePopperPoint);
    var oppositeSidePopperCollisions = getCollisions(updatedOppositeSidePopperPoint, collisionTolerance);
    // adjust side accounting for collisions / opposite side collisions
    var adjustedSide = getSideAccountingForCollisions(side, popperCollisions, oppositeSidePopperCollisions);
    // adjust alignnment accounting for collisions
    var adjustedAlign = getAlignAccountingForCollisions(popperSize, targetRect, side, align, popperCollisions);
    var adjustedPopperPoint = allPlacementPoints[adjustedSide][adjustedAlign];
    // compute adjusted popper / arrow / transform origin styles
    var popperStyles = getPlacementStylesForPoint(adjustedPopperPoint);
    var arrowStyles = {};
    if (arrowSize) {
        arrowStyles = getPopperArrowStyles({
            popperSize: popperSize,
            arrowSize: arrowSize,
            arrowOffset: arrowOffset,
            side: adjustedSide,
            align: adjustedAlign,
        });
    }
    var transformOriginStyles = getTransformOriginStyles(popperSize, adjustedSide, adjustedAlign, arrowOffset, arrowSize);
    return {
        popperStyles: popperStyles,
        arrowStyles: arrowStyles,
        transformOriginStyles: transformOriginStyles,
        adjustedSide: adjustedSide,
        adjustedAlign: adjustedAlign,
    };
}
function getAllPlacementPoints(popperSize, targetRect, sideOffset, alignOffset, arrowSize) {
    if (sideOffset === void 0) { sideOffset = 0; }
    if (alignOffset === void 0) { alignOffset = 0; }
    var arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;
    var x = getPopperSlotsForAxis(targetRect, popperSize, 'x');
    var y = getPopperSlotsForAxis(targetRect, popperSize, 'y');
    var topY = y.before + sideOffset - arrowBaseToTipLength; // prettier-ignore
    var bottomY = y.after - sideOffset + arrowBaseToTipLength; // prettier-ignore
    var leftX = x.before + sideOffset - arrowBaseToTipLength; // prettier-ignore
    var rightX = x.after - sideOffset + arrowBaseToTipLength; // prettier-ignore
    // prettier-ignore
    var map = {
        top: {
            start: { x: x.start + alignOffset, y: topY },
            center: { x: x.center, y: topY },
            end: { x: x.end - alignOffset, y: topY },
        },
        right: {
            start: { x: rightX, y: y.start + alignOffset },
            center: { x: rightX, y: y.center },
            end: { x: rightX, y: y.end - alignOffset },
        },
        bottom: {
            start: { x: x.start + alignOffset, y: bottomY },
            center: { x: x.center, y: bottomY },
            end: { x: x.end - alignOffset, y: bottomY },
        },
        left: {
            start: { x: leftX, y: y.start + alignOffset },
            center: { x: leftX, y: y.center },
            end: { x: leftX, y: y.end - alignOffset },
        },
    };
    return map;
}
function getPopperSlotsForAxis(targetRect, popperSize, axis) {
    var startSide = axis === 'x' ? 'left' : 'top';
    var targetStart = targetRect[startSide];
    var dimension = axis === 'x' ? 'width' : 'height';
    var targetDimension = targetRect[dimension];
    var popperDimension = popperSize[dimension];
    // prettier-ignore
    return {
        before: targetStart - popperDimension,
        start: targetStart,
        center: targetStart + (targetDimension - popperDimension) / 2,
        end: targetStart + targetDimension - popperDimension,
        after: targetStart + targetDimension,
    };
}
/**
 * Gets an adjusted side based on collision information
 */
function getSideAccountingForCollisions(
/** The side we want to ideally position to */
side, 
/** The collisions for this given side */
collisions, 
/** The collisions for the opposite side (if we were to swap side) */
oppositeSideCollisions) {
    var oppositeSide = getOppositeSide(side);
    // in order to prevent premature jumps
    // we only swap side if there's enough space to fit on the opposite side
    return collisions[side] && !oppositeSideCollisions[oppositeSide] ? oppositeSide : side;
}
/**
 * Gets an adjusted alignment based on collision information
 */
function getAlignAccountingForCollisions(
/** The size of the popper to place */
popperSize, 
/** The size of the target we are placing around */
targetSize, 
/** The final side */
side, 
/** The desired align */
align, 
/** The collisions */
collisions) {
    var isHorizontalSide = side === 'top' || side === 'bottom';
    var startBound = isHorizontalSide ? 'left' : 'top';
    var endBound = isHorizontalSide ? 'right' : 'bottom';
    var dimension = isHorizontalSide ? 'width' : 'height';
    var isTargetBigger = targetSize[dimension] > popperSize[dimension];
    if (align === 'start' || align === 'center') {
        if ((collisions[startBound] && isTargetBigger) || (collisions[endBound] && !isTargetBigger)) {
            return 'end';
        }
    }
    if (align === 'end' || align === 'center') {
        if ((collisions[endBound] && isTargetBigger) || (collisions[startBound] && !isTargetBigger)) {
            return 'start';
        }
    }
    return align;
}
function getPlacementStylesForPoint(point) {
    var x = Math.round(point.x + window.pageXOffset);
    var y = Math.round(point.y + window.pageYOffset);
    return {
        position: 'absolute',
        top: 0,
        left: 0,
        willChange: 'transform',
        transform: "translate3d(" + x + "px, " + y + "px, 0)",
    };
}
function getTransformOriginStyles(popperSize, side, align, arrowOffset, arrowSize) {
    var isHorizontalSide = side === 'top' || side === 'bottom';
    var arrowBaseLength = arrowSize ? arrowSize.width : 0;
    var arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;
    var sideOffset = arrowBaseToTipLength;
    var alignOffset = arrowBaseLength / 2 + arrowOffset;
    var x = '';
    var y = '';
    if (isHorizontalSide) {
        x = {
            start: alignOffset + "px",
            center: 'center',
            end: popperSize.width - alignOffset + "px",
        }[align];
        y = side === 'top' ? popperSize.height + sideOffset + "px" : -sideOffset + "px";
    }
    else {
        x = side === 'left' ? popperSize.width + sideOffset + "px" : -sideOffset + "px";
        y = {
            start: alignOffset + "px",
            center: 'center',
            end: popperSize.height - alignOffset + "px",
        }[align];
    }
    return {
        transformOrigin: x + " " + y,
    };
}

var Popover = React.forwardRef(function Popover(props, forwardedRef) {
    var children = props.children, isOpen = props.isOpen, onClose = props.onClose, refToFocusOnOpen = props.refToFocusOnOpen, refToFocusOnClose = props.refToFocusOnClose, _a = props.shouldCloseOnEscape, shouldCloseOnEscape = _a === void 0 ? true : _a, _b = props.shouldCloseOnOutsideClick, shouldCloseOnOutsideClick = _b === void 0 ? true : _b, _c = props.shouldBlockOutsideClick, shouldBlockOutsideClick = _c === void 0 ? false : _c, _d = props.shouldLockScroll, shouldLockScroll = _d === void 0 ? false : _d, targetRef = props.targetRef, _e = props.side, side = _e === void 0 ? 'bottom' : _e, _f = props.sideOffset, sideOffset = _f === void 0 ? -5 : _f, _g = props.align, align = _g === void 0 ? 'center' : _g, _h = props.alignOffset, alignOffset = _h === void 0 ? 0 : _h, _j = props.arrowOffset, arrowOffset = _j === void 0 ? 10 : _j, _k = props.noArrow, noArrow = _k === void 0 ? false : _k, _l = props.collisionTolerance, collisionTolerance = _l === void 0 ? 0 : _l, styleConfig = props.styleConfig, contentProps = __rest(props, ["children", "isOpen", "onClose", "refToFocusOnOpen", "refToFocusOnClose", "shouldCloseOnEscape", "shouldCloseOnOutsideClick", "shouldBlockOutsideClick", "shouldLockScroll", "targetRef", "side", "sideOffset", "align", "alignOffset", "arrowOffset", "noArrow", "collisionTolerance", "styleConfig"]);
    var debugContext = useDebugContext();
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var contentStyles = getPartStyles('content', styleConfig, variantsMap);
    var arrowStyles = getPartStyles('arrow', styleConfig, variantsMap);
    var targetRect = useRect({ refToObserve: targetRef, isObserving: isOpen });
    var popperRef = React.useRef(null);
    var popperSize = useSize({ refToObserve: popperRef, isObserving: isOpen });
    var arrowRef = React.useRef(null);
    var arrowSize = useSize({ refToObserve: arrowRef, isObserving: isOpen });
    var _m = getPlacementData({
        popperSize: popperSize,
        targetRect: targetRect,
        arrowSize: arrowSize,
        arrowOffset: arrowOffset,
        side: side,
        sideOffset: sideOffset,
        align: align,
        alignOffset: alignOffset,
        collisionTolerance: collisionTolerance,
        shouldAvoidCollisions: !debugContext.disableCollisionChecking,
    }), popperStyles = _m.popperStyles, arrowPlacementStyles = _m.arrowStyles;
    /**
     * Prevent a click on the target to close the popover (click outside)
     * BUT instantly reopen it (click on target)
     *
     * when:
     * - outside clicks should close the popover
     * - but outside clicks are not blocked */
    React.useEffect(function () {
        var targetElement = targetRef.current;
        if (!targetElement)
            return;
        var originalPointerEvents = targetElement.style.pointerEvents;
        if (shouldCloseOnOutsideClick && !shouldBlockOutsideClick && isOpen) {
            targetElement.style.pointerEvents = 'none';
            return function () {
                targetElement.style.pointerEvents = originalPointerEvents;
            };
        }
    }, [shouldCloseOnOutsideClick, shouldBlockOutsideClick, isOpen, targetRef]);
    return isOpen ? (React.createElement(Portal, null,
        React.createElement(Lock, { isActive: debugContext.disableLock ? false : isOpen, onDeactivate: onClose, refToFocusOnActivation: refToFocusOnOpen, refToFocusOnDeactivation: refToFocusOnClose, shouldDeactivateOnEscape: shouldCloseOnEscape, shouldDeactivateOnOutsideClick: shouldCloseOnOutsideClick, shouldBlockOutsideClick: shouldBlockOutsideClick, shouldLockScroll: shouldLockScroll }, function (lockContainerRef) { return (React.createElement("div", { style: popperStyles },
            React.createElement("div", { ref: popperRef },
                React.createElement(ContentPart$1, __assign({}, contentProps, { ref: composeRefs(forwardedRef, lockContainerRef), contentStyles: contentStyles }), children)),
            noArrow ? null : (React.createElement("span", { style: arrowPlacementStyles },
                React.createElement(Arrow, { ref: arrowRef, 
                    // at this point `arrowStyles` already has the variants applied
                    // so we can just create styleConfig with base styles on the fly
                    styleConfig: {
                        base: {
                            arrow: arrowStyles,
                        },
                    } }))))); }))) : null;
});
Popover.displayName = 'Popover';
var ContentPart$1 = styled('div').attrs({ 'data-part-id': 'content' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b = _a.contentStyles, contentStyles = _b === void 0 ? {} : _b;
    return contentStyles.normal;
}, 
// add system support
boxSystemProps);
ContentPart$1.displayName = 'ContentPart';

var _a$1;
var systemProps$k = boxSystemProps;
var systemPropNames$1 = boxSystemPropNames;
var Radio = React.forwardRef(function Radio(props, forwardedRef) {
    var className = props.className, style = props.style, styleConfig = props.styleConfig;
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var radioStyles = getPartStyles('radio', styleConfig, variantsMap);
    var iconStyles = getPartStyles('icon', styleConfig, variantsMap);
    var systemProps = pick(props, systemPropNames$1);
    var inputProps = omit(props, systemPropNames$1);
    return (React.createElement(Wrapper$1, __assign({ className: className, style: style }, systemProps),
        React.createElement(Input$2, __assign({}, inputProps, { type: "radio", ref: forwardedRef })),
        React.createElement(RadioPart, { radioStyles: radioStyles },
            React.createElement(IconPart$1, { iconStyles: iconStyles }))));
});
Radio.displayName = 'Radio';
var Wrapper$1 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-block',
    verticalAlign: 'middle',
    position: 'relative',
}, 
// add system support
systemProps$k);
var Input$2 = styled('input')(
// reset styles
cssReset('input'), 
// functional styles
{
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    zIndex: 1,
    opacity: 0,
    '&:disabled': { pointerEvents: 'none' },
});
var RadioPart = styled('div').attrs({ 'data-part-id': 'radio' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    zIndex: 0,
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.radioStyles, radioStyles = _c === void 0 ? {} : _c;
    var normal = radioStyles.normal, hover = radioStyles.hover, focus = radioStyles.focus, active = radioStyles.active, checked = radioStyles.checked, disabled = radioStyles.disabled;
    return __assign(__assign({}, normal), (_b = {}, _b[Input$2 + ":hover + &"] = hover, _b[Input$2 + ":focus + &"] = focus, _b[Input$2 + ":active + &"] = active, _b[Input$2 + ":checked + &"] = checked, _b[Input$2 + ":disabled + &"] = disabled, _b));
});
RadioPart.displayName = 'RadioPart';
var IconPart$1 = styled('div').attrs({ 'data-part-id': 'icon' })(
// reset styles
cssReset('div'), (_a$1 = {
        position: 'absolute',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        pointerEvents: 'none',
        opacity: 0
    },
    _a$1[Input$2 + ":checked + " + RadioPart + " &"] = {
        opacity: 1,
    },
    _a$1), 
// apply style config
function (_a) {
    var _b = _a.iconStyles, iconStyles = _b === void 0 ? {} : _b;
    return iconStyles.normal;
});
IconPart$1.displayName = 'IconPart';

var RightClickMenuContext = React.createContext({ isOpen: false, setAnchorPoint: function () { } });
function RightClickMenu(_a) {
    var menu = _a.menu, children = _a.children;
    var _b = React.useState(), anchorPoint = _b[0], setAnchorPoint = _b[1];
    var isOpen = anchorPoint !== undefined;
    var rightClickableTargetRef = React.useRef(null);
    var menuProps = {
        isOpen: isOpen,
        onClose: function () { return setAnchorPoint(undefined); },
        anchorPoint: anchorPoint,
        calculateMenuPosition: calculateRightClickMenuPosition,
        refToFocusOnClose: rightClickableTargetRef,
    };
    var menuClone = React.cloneElement(menu, menuProps);
    return (React.createElement(RightClickMenuContext.Provider, { value: { isOpen: isOpen, setAnchorPoint: setAnchorPoint, rightClickableTargetRef: rightClickableTargetRef } },
        children,
        menuClone));
}
var IsNestedRightClickableContext = React.createContext(false);
function RightClickable(_a) {
    var children = _a.children;
    var _b = React.useContext(RightClickMenuContext), isOpen = _b.isOpen, setAnchorPoint = _b.setAnchorPoint, rightClickableTargetRef = _b.rightClickableTargetRef;
    var isNested = React.useContext(IsNestedRightClickableContext);
    var getChildrenProps = function (props) {
        if (props === void 0) { props = {}; }
        var ref = props.ref, originalOnContextMenu = props.onContextMenu, originalOnMouseDownCapture = props.onMouseDownCapture;
        return __assign(__assign({}, props), { ref: composeRefs(ref, rightClickableTargetRef), 
            // prevent focus from happening succintly before the menu opens
            onMouseDownCapture: composeEventHandlers(originalOnMouseDownCapture, function (event) {
                if (
                // right mouse button
                event.button === 2 ||
                    // left mouse button + ctrl key (MacOS)
                    (event.button === 0 && event.ctrlKey)) {
                    event.preventDefault();
                }
            }), onContextMenu: composeEventHandlers(originalOnContextMenu, function (event) {
                event.preventDefault();
                // if this right click area is nested inside another one (ie. for another higher level menu)
                // we stop propagation so that the higher level menu doesn't trigger.
                if (isNested) {
                    event.stopPropagation();
                }
                var point = { x: event.clientX, y: event.clientY };
                setAnchorPoint(point);
            }) });
    };
    return (React.createElement(IsNestedRightClickableContext.Provider, { value: true }, typeof children === 'function'
        ? children(isOpen, getChildrenProps)
        : React.cloneElement(React.Children.only(children), getChildrenProps(children.props))));
}

function isChildOfType(child, type) {
    if (!React.isValidElement(child)) {
        return false;
    }
    // @ts-ignore
    return child.type === type || child.type.__renderedComponent === type;
}

var systemProps$l = boxSystemProps;
var systemPropNames$2 = boxSystemPropNames;
var UseNativeSelectContext = React.createContext(false);
function Option(props) {
    return null;
}
function OptionGroup(props) {
    return null;
}
function getSelectMenuChildren(children) {
    var menuChildren = [];
    var index = -1;
    React.Children.forEach(children, function (child) {
        if (isChildOfType(child, Option)) {
            var _a = child.props, label = _a.label, value = _a.value, disabled = _a.disabled;
            index++;
            menuChildren.push({
                type: 'option',
                item: { label: label, value: value, isDisabled: Boolean(disabled), index: index },
            });
        }
        if (isChildOfType(child, OptionGroup)) {
            var _b = child.props, isGroupDisabled_1 = _b.disabled, label = _b.label;
            var hasGroupLabel_1 = label !== undefined;
            menuChildren.push({ type: 'separator' });
            if (label) {
                menuChildren.push({ type: 'label', label: label });
            }
            React.Children.forEach(child.props.children, function (child) {
                if (isChildOfType(child, Option)) {
                    var _a = child.props, label_1 = _a.label, value = _a.value, isOptionDisabled = _a.disabled;
                    index++;
                    menuChildren.push({
                        type: 'option',
                        isInGroup: hasGroupLabel_1,
                        item: {
                            label: label_1,
                            value: value,
                            isDisabled: Boolean(isGroupDisabled_1) || Boolean(isOptionDisabled),
                            index: index,
                        },
                    });
                }
            });
            menuChildren.push({ type: 'separator' });
        }
    });
    // remove unnecessary separators
    menuChildren = menuChildren.filter(function (option, index, arr) {
        if (option.type === 'separator') {
            if (index === 0)
                return false;
            if (index === arr.length - 1)
                return false;
            var previousItem = arr[index - 1];
            if (previousItem && previousItem.type === 'separator')
                return false;
        }
        return true;
    });
    return menuChildren;
}
function getItemsFromChildren(children) {
    var selectMenuChildren = getSelectMenuChildren(children);
    return getItemsFromSelectMenuChildren(selectMenuChildren);
}
function getItemsFromSelectMenuChildren(menuChildren) {
    var items = [];
    menuChildren.forEach(function (child) {
        if (child.type === 'option') {
            items.push(child.item);
        }
    });
    return items;
}
function useSelectValueState(items, props) {
    var valueProp = props.value, defaultValue = props.defaultValue, onValueChange = props.onValueChange;
    // we need to check if the user is passing a value
    // even if it's `undefined`, because `undefined` is allowed
    // but could still mean we want to control the value
    var isValueControlled = 'value' in props;
    return useControlledState({
        prop: isValueControlled ? getDefaultValue(items, valueProp) : valueProp,
        defaultProp: getDefaultValue(items, defaultValue),
        onChange: onValueChange,
        unstable__isControlled: isValueControlled,
    });
}
function getDefaultValue(items, value) {
    var allItemValues = items.map(function (item) { return item.value; });
    var selectableItems = getSelectableItems(items);
    var selectableItemValues = selectableItems.map(function (item) { return item.value; });
    var firstSelectableItemValue = selectableItemValues[0];
    // we use the first value (amongst all, even disabled ones) if:
    // - there's no defined value
    // - all options are disabled
    if (value === undefined && items.every(function (item) { return item.isDisabled; })) {
        return allItemValues[0];
    }
    // we use the first selectable value if:
    // - there's no defined value
    // - there are no item (at all, even disabled ones) with a value that matches the value
    if (value === undefined || !allItemValues.includes(value)) {
        return firstSelectableItemValue;
    }
    return value;
}
var selectButtonFunctionalStyles = {
    display: 'inline-flex',
    alignItems: 'center',
    lineHeight: '1',
    cursor: 'default',
    userSelect: 'none',
    textAlign: 'left',
};
var selectButtonLabelFunctionalStyles = {
    flex: 1,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
};
function ButtonIconPart(props) {
    return (React.createElement(ButtonIconSvgPart, __assign({}, props, { "data-part-id": "buttonIcon", xmlns: "http://www.w3.org/2000/svg", width: "6", height: "15", viewBox: "0 0 6 15", fill: "none", stroke: "currentColor" }),
        React.createElement("path", { d: "M5 5.5L3 3.5L1 5.5", strokeLinecap: "round", strokeLinejoin: "round" }),
        React.createElement("path", { d: "M5 9.5L3 11.5L1 9.5", strokeLinecap: "round", strokeLinejoin: "round" })));
}
var ButtonIconSvgPart = styled('svg')(
// reset styles
cssReset('svg'), 
// functional styles
{
    flex: '0 0 auto',
}, 
// apply style config
function (_a) {
    var _b = _a.buttonIconStyles, buttonIconStyles = _b === void 0 ? {} : _b;
    return buttonIconStyles.normal;
});

/**
 * This component can be used by itself if we don't need to style the menu.
 * The benefits are that it will use a lot less code.
 */
var SelectWithNativeMenu = React.forwardRef(function SelectWithNativeMenu(props, forwardedRef) {
    var children = props.children, className = props.className, style = props.style, styleConfig = props.styleConfig, otherInputProps = __rest(props, ["children", "className", "style", "styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var buttonStyles = getPartStyles('button', styleConfig, variantsMap);
    var buttonIconStyles = getPartStyles('buttonIcon', styleConfig, variantsMap);
    var systemProps = pick(otherInputProps, systemPropNames$2, 'sx');
    var inputProps = omit(otherInputProps, systemPropNames$2, 'sx');
    var items = getItemsFromChildren(children);
    var _a = useSelectValueState(items, props), value = _a[0], setValue = _a[1];
    var selectedOptionLabel = getItemLabelForValue(items, value);
    var nativeSelectProps = getNativeSelectProps(inputProps);
    return (
    // Provide the native context so users can use the same `<Option>` and `<OptionGroup />`
    // regardless of what top-level component they are using (`Select`, `SelectWithNativeMenu`, `SelectWithCustomMenu`)
    React.createElement(UseNativeSelectContext.Provider, { value: true },
        React.createElement(Wrapper$2, __assign({ className: className, style: style }, systemProps),
            React.createElement(NativeSelect, __assign({}, nativeSelectProps, { ref: forwardedRef, buttonStyles: buttonStyles, value: value, onChange: function (event) { return setValue(event.target.value); } }), children),
            React.createElement(ButtonPart$1, { "aria-hidden": true, buttonStyles: buttonStyles },
                React.createElement("span", { style: selectButtonLabelFunctionalStyles }, selectedOptionLabel),
                React.createElement(ButtonIconPart, { buttonIconStyles: buttonIconStyles })))));
});
SelectWithNativeMenu.displayName = 'SelectWithNativeMenu';
var Wrapper$2 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-block',
    position: 'relative',
}, 
// add system support
systemProps$l, 
// add sx prop
radixSystem.sx);
var NativeSelect = styled('select')(
// reset styles
cssReset('select'), 
// functional styles
//
// we apply the same base styles as the custom button
// to make sure the size matches nicely as well as fonts, etc
// we also apply the `normal` button styles for the same reasons (see below)
selectButtonFunctionalStyles, {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    opacity: 0,
    '&:disabled': { pointerEvents: 'none' },
}, 
// apply style config
function (_a) {
    var _b = _a.buttonStyles, buttonStyles = _b === void 0 ? {} : _b;
    return buttonStyles.normal;
});
NativeSelect.displayName = 'NativeSelect';
var ButtonPart$1 = styled('div').attrs({ 'data-part-id': 'button' })(
// reset styles
cssReset('div'), 
// functional styles
selectButtonFunctionalStyles, 
// functional styles specific to native implementation
{
    width: '100%',
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.buttonStyles, buttonStyles = _c === void 0 ? {} : _c;
    var normal = buttonStyles.normal, hover = buttonStyles.hover, focus = buttonStyles.focus, active = buttonStyles.active, disabled = buttonStyles.disabled;
    return __assign(__assign({}, normal), (_b = {}, _b[NativeSelect + ":hover + &"] = hover, _b[NativeSelect + ":focus + &"] = focus, _b[NativeSelect + ":active + &"] = active, _b[NativeSelect + ":disabled + &"] = disabled, _b));
});
ButtonPart$1.displayName = 'ButtonPart';
var PROPS_TO_NOT_FORWARD_TO_NATIVE_SELECT = [
    // we remove className and style because they are passed to the wrapper
    'className',
    'style',
    // we remove `defaultValue` because the native select we use ends up being controlled
    // in all cases (1. by the user, ie. value + onChange, 2. by us internally when uncontrolled by user)
    'defaultValue',
    'onValueChange',
    'styleConfig',
];
function getNativeSelectProps(props) {
    var nativeSelectProps = __assign({}, props);
    PROPS_TO_NOT_FORWARD_TO_NATIVE_SELECT.forEach(function (prop) { return delete nativeSelectProps[prop]; });
    return nativeSelectProps;
}

// We use `HTMLSelectElement` here so we can provide a unified experience in top-level `Select` primitive
var SelectWithCustomMenu = React.forwardRef(function SelectWithCustomMenu(props, forwardedRef) {
    var children = props.children, className = props.className, style = props.style, id = props.id, name = props.name, autoFocus = props.autoFocus, disabled = props.disabled, required = props.required, readOnly = props.readOnly, tabIndex = props.tabIndex, valueProp = props.value, onValueChange = props.onValueChange, defaultValue = props.defaultValue, isOpenProp = props.isOpen, onIsOpenChange = props.onIsOpenChange, styleConfig = props.styleConfig, originalOnMouseDown = props.onMouseDown, originalOnKeyDown = props.onKeyDown, otherInputProps = __rest(props, ["children", "className", "style", "id", "name", "autoFocus", "disabled", "required", "readOnly", "tabIndex", "value", "onValueChange", "defaultValue", "isOpen", "onIsOpenChange", "styleConfig", "onMouseDown", "onKeyDown"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var buttonStyles = getPartStyles('button', styleConfig, variantsMap);
    var buttonIconStyles = getPartStyles('buttonIcon', styleConfig, variantsMap);
    var menuStyles = getPartStyles('menu', styleConfig, variantsMap);
    var scrollIndicatorStyles = getPartStyles('scrollIndicator', styleConfig, variantsMap);
    var itemStyles = getPartStyles('item', styleConfig, variantsMap);
    var itemIconStyles = getPartStyles('itemIcon', styleConfig, variantsMap);
    var labelStyles = getPartStyles('label', styleConfig, variantsMap);
    var separatorStyles = getPartStyles('separator', styleConfig, variantsMap);
    var systemProps = pick(otherInputProps, systemPropNames$2, 'sx');
    var inputProps = omit(otherInputProps, systemPropNames$2, 'sx');
    // start by extracting a simple datastructure from the options
    var menuChildren = getSelectMenuChildren(children);
    var items = getItemsFromSelectMenuChildren(menuChildren);
    var generatedSelectId = "select-" + useId();
    var selectId = String(id === undefined ? generatedSelectId : id);
    var buttonId = selectId;
    var menuId = selectId + "-menu";
    var _a = useControlledState({ prop: isOpenProp, onChange: onIsOpenChange }), _isOpen = _a[0], setIsOpen = _a[1];
    var isOpen = Boolean(_isOpen);
    var prevIsOpen = usePrevious(isOpen);
    var _b = React.useState(), highlightedIndex = _b[0], setHighlightedIndex = _b[1];
    var _c = useSelectValueState(items, props), value = _c[0], setValue = _c[1];
    var _d = useSelfResettingState(), typeaheadBuffer = _d[0], setTypeaheadBuffer = _d[1];
    var buttonRef = React.useRef(null);
    var buttonTextRef = React.useRef(null);
    var selectedOptionLabel = getItemLabelForValue(items, value);
    // whenever the menu opens:
    // - highlight the selected option
    React.useEffect(function () {
        var hasOpened = !prevIsOpen && isOpen;
        if (hasOpened) {
            var index = getItemIndexForValue(items, value);
            var item = items[index];
            if (item && !item.isDisabled) {
                setHighlightedIndex(index);
            }
        }
    }, [prevIsOpen, isOpen, items, value]);
    var closeMenu = React.useCallback(function closeMenu() {
        setIsOpen(false);
    }, [setIsOpen]);
    var selectItem = React.useCallback(function selectItem(item) {
        setValue(item ? item.value : undefined);
    }, [setValue]);
    return (React.createElement(React.Fragment, null,
        React.createElement(ButtonPart$2
        // accessibility
        , __assign({ 
            // accessibility
            id: buttonId, tabIndex: tabIndex, "aria-label": props['aria-label'], "aria-labelledby": props['aria-labelledby'] === undefined ? buttonId : buttonId + " " + props['aria-labelledby'], "aria-describedby": props['aria-describedby'], "aria-required": required, "aria-haspopup": "listbox", "aria-owns": isOpen ? menuId : undefined, "aria-expanded": isOpen === true ? true : undefined, 
            // other props
            ref: buttonRef, className: className, style: style, buttonStyles: buttonStyles }, systemProps, { type: "button", disabled: disabled, autoFocus: autoFocus, onMouseDown: composeEventHandlers(originalOnMouseDown, function (event) {
                if (Boolean(readOnly)) {
                    return;
                }
                // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)
                // but not when the control key is pressed (avoiding MacOS right click)
                if (event.button === 0 && event.ctrlKey === false) {
                    setIsOpen(true);
                }
            }), onKeyDown: composeEventHandlers(originalOnKeyDown, function (event) {
                if (Boolean(readOnly)) {
                    return;
                }
                // disable button defaults
                if (event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                }
                if (canProcessTypeahead(event)) {
                    var isBuffering = typeaheadBuffer !== undefined;
                    if (event.key === ' ' && !isBuffering) {
                        setIsOpen(true);
                    }
                    else {
                        var updatedBuffer = (typeaheadBuffer || '') + event.key;
                        setTypeaheadBuffer(updatedBuffer);
                        var typeaheadIndex = getTypeaheadIndex({
                            items: items,
                            currentIndex: getItemIndexForValue(items, value),
                            searchBuffer: updatedBuffer,
                        });
                        var typeaheadValue = typeaheadIndex !== undefined ? items[typeaheadIndex].value : undefined;
                        setValue(typeaheadValue);
                    }
                }
                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    event.preventDefault();
                    setIsOpen(true);
                }
            }) }),
            React.createElement("span", { ref: buttonTextRef, style: selectButtonLabelFunctionalStyles }, selectedOptionLabel),
            React.createElement(ButtonIconPart, { buttonIconStyles: buttonIconStyles })),
        React.createElement(VisuallyHidden, null,
            React.createElement("input", __assign({}, inputProps, { ref: forwardedRef, type: "text", "aria-hidden": true, value: value, onChange: function () { }, name: name, readOnly: readOnly, 
                // focusable programmatically but not in the tab order
                tabIndex: -1, 
                // if the input gets focused (via forwardedRef) we move focus to the button
                onFocus: composeEventHandlers(inputProps.onFocus, function () {
                    var _a;
                    (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                }) }))),
        React.createElement(Menu, { id: menuId, role: "listbox", buttonRef: buttonRef, buttonTextRef: buttonTextRef, isOpen: isOpen, onClose: closeMenu, highlightedIndex: highlightedIndex, onHighlightedIndexChange: setHighlightedIndex, onItemSelected: selectItem, calculateMenuPosition: calculateSelectMenuPosition, 
            // at this point all the styles already have the variants applied
            // so we can just create styleConfig with base styles on the fly
            styleConfig: {
                base: {
                    menu: menuStyles,
                    scrollIndicator: scrollIndicatorStyles,
                    item: itemStyles,
                    itemIcon: itemIconStyles,
                    label: labelStyles,
                    separator: separatorStyles,
                },
            } }, menuChildren.map(function (child, arrayIndex) {
            if (child.type === 'separator') {
                return React.createElement(MenuItemSeparator, { key: arrayIndex });
            }
            if (child.type === 'label') {
                return React.createElement(MenuItemLabel, { key: arrayIndex }, child.label);
            }
            if (child.type === 'option') {
                var _a = child.item, label = _a.label, optionValue = _a.value, isDisabled = _a.isDisabled, index = _a.index;
                var isHighlighted = index === highlightedIndex;
                var isGrouped = Boolean(child.isInGroup);
                var isSelected = optionValue === value;
                return (React.createElement(MenuItem, { key: optionValue, role: "option", "aria-selected": isHighlighted, label: label, value: optionValue, disabled: isDisabled, grouped: isGrouped, selected: isSelected, isReference: isSelected }));
            }
            return null;
        }))));
});
SelectWithCustomMenu.displayName = 'SelectWithCustomMenu';
var ButtonPart$2 = styled('button').attrs({ 'data-part-id': 'button' })(
// reset styles
cssReset('button'), 
// functional styles
selectButtonFunctionalStyles, {
    '&:disabled': { pointerEvents: 'none' },
}, 
// apply style config
function (_a) {
    var _b = _a.buttonStyles, buttonStyles = _b === void 0 ? {} : _b;
    var normal = buttonStyles.normal, hover = buttonStyles.hover, focus = buttonStyles.focus, active = buttonStyles.active, disabled = buttonStyles.disabled;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active, '&:disabled': disabled });
}, 
// add system support
systemProps$l, 
// add sx prop
radixSystem.sx);
ButtonPart$2.displayName = 'ButtonPart';

var Select = React.forwardRef(function Select(props, forwardedRef) {
    var isNativeProp = props.isNative, selectProps = __rest(props, ["isNative"]);
    var _a = React.useState(false), isTouching = _a[0], setIsTouching = _a[1];
    var isNative = isNativeProp !== undefined ? isNativeProp : isTouching;
    var items = getItemsFromChildren(props.children);
    // we control our select internally in order to solve the following issue:
    // - if the developer is not controlling the value (uses `defaultValue` rather than `value` + `onValueChange`)
    // - and if the user has already interacted with the component (changed to a different value)
    // - and if the component re-renders because we're switching to native, we would lose the current value
    // => we would lose the currently selected value as it wasn't controlled.
    var _b = useSelectValueState(items, props), value = _b[0], setValue = _b[1];
    // determine if the user is "actually" touching the screen
    // See: http://www.stucox.com/blog/you-cant-detect-a-touchscreen/
    // See: https://codeburst.io/the-only-way-to-detect-touch-with-javascript-7791a3346685
    React.useEffect(function () {
        document.addEventListener('touchstart', onTouchStart);
        return stopListening;
        function onTouchStart() {
            setIsTouching(true);
            stopListening();
        }
        function stopListening() {
            document.removeEventListener('touchstart', onTouchStart);
        }
    }, []);
    return (React.createElement(UseNativeSelectContext.Provider, { value: isNative }, isNative ? (React.createElement(SelectWithNativeMenu, __assign({}, selectProps, { ref: forwardedRef, value: value, onValueChange: setValue }))) : (React.createElement(SelectWithCustomMenu, __assign({}, selectProps, { ref: forwardedRef, value: value, onValueChange: setValue })))));
});
Select.displayName = 'Select';
function Option$1(props) {
    var isNative = React.useContext(UseNativeSelectContext);
    // NOTE: although the spec says `label` takes precendence over the text content (`children`)
    // iOS seem to need the text content to properly render the option labels
    // also Firefox seems to ignore label prop too, rendering nothing.
    return isNative ? React.createElement("option", __assign({}, props, { children: props.label })) : React.createElement(Option, __assign({}, props));
}
Option$1.__renderedComponent = Option;
function OptionGroup$1(props) {
    var isNative = React.useContext(UseNativeSelectContext);
    var OptionGroupComponent = isNative ? 'optgroup' : OptionGroup;
    return React.createElement(OptionGroupComponent, __assign({}, props));
}
OptionGroup$1.__renderedComponent = OptionGroup;

var Sheet = React.forwardRef(function Sheet(props, forwardedRef) {
    var children = props.children, isOpen = props.isOpen, onClose = props.onClose, _a = props.side, side = _a === void 0 ? 'left' : _a, refToFocusOnOpen = props.refToFocusOnOpen, refToFocusOnClose = props.refToFocusOnClose, _b = props.shouldCloseOnEscape, shouldCloseOnEscape = _b === void 0 ? true : _b, _c = props.shouldCloseOnOutsideClick, shouldCloseOnOutsideClick = _c === void 0 ? true : _c, styleConfig = props.styleConfig, sheetProps = __rest(props, ["children", "isOpen", "onClose", "side", "refToFocusOnOpen", "refToFocusOnClose", "shouldCloseOnEscape", "shouldCloseOnOutsideClick", "styleConfig"]);
    var debugContext = useDebugContext();
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(__assign(__assign({}, props), { side: side }), variantNames);
    var overlayStyles = getPartStyles('overlay', styleConfig, variantsMap);
    var sheetStyles = getPartStyles('sheet', styleConfig, variantsMap);
    return (React.createElement(PresenceTransition, { isPresent: isOpen },
        React.createElement(Portal, null,
            React.createElement(Overlay
            // at this point `overlayStyles` already has the variants applied
            // so we can just create styleConfig with base styles on the fly
            , { 
                // at this point `overlayStyles` already has the variants applied
                // so we can just create styleConfig with base styles on the fly
                styleConfig: {
                    base: { overlay: overlayStyles },
                }, style: { pointerEvents: debugContext.disableLock ? 'none' : 'auto' } }),
            React.createElement(WrapperPart$2, null,
                React.createElement(Lock, { isActive: debugContext.disableLock ? false : isOpen, onDeactivate: onClose, refToFocusOnActivation: refToFocusOnOpen, refToFocusOnDeactivation: refToFocusOnClose, shouldDeactivateOnEscape: shouldCloseOnEscape, shouldDeactivateOnOutsideClick: shouldCloseOnOutsideClick, shouldBlockOutsideClick: true, shouldLockScroll: true }, function (lockContainerRef) { return (React.createElement(PartTransition, null,
                    React.createElement(SheetPart, __assign({}, sheetProps, { ref: composeRefs(forwardedRef, lockContainerRef), 
                        // accessibility
                        role: "dialog", "aria-modal": true, 
                        // other props
                        side: side, sheetStyles: sheetStyles }), children))); })))));
});
Sheet.displayName = 'Sheet';
var WrapperPart$2 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'fixed',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: 'none',
});
WrapperPart$2.displayName = 'WrapperPart';
var SheetPart = styled('div').attrs({ 'data-part-id': 'sheet' })(
// reset styles
cssReset('div'), 
// functional styles
function (_a) {
    var _b;
    var side = _a.side;
    return (_b = {
            pointerEvents: 'auto',
            position: 'absolute',
            top: 0,
            bottom: 0
        },
        _b[side] = 0,
        _b);
}, 
// apply style config
function (_a) {
    var _b = _a.sheetStyles, sheetStyles = _b === void 0 ? {} : _b;
    var normal = sheetStyles.normal, enter = sheetStyles.enter, opened = sheetStyles.opened, exit = sheetStyles.exit;
    return __assign(__assign({}, normal), { '&.enter, &.appear': enter, '&.enter-active, &.appear-active': opened, '&.exit': opened, '&.exit-active': exit });
}, 
// add system support
boxSystemProps);
SheetPart.displayName = 'SheetPart';

var systemProps$m = boxSystemProps;
var systemPropNames$3 = boxSystemPropNames;
var Slider = React.forwardRef(function Slider(props, forwardedRef) {
    var _a = props.min, min = _a === void 0 ? 0 : _a, _b = props.max, max = _b === void 0 ? 100 : _b, value = props.value, originalOnChange = props.onChange, styleConfig = props.styleConfig;
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var sliderStyles = getPartStyles('slider', styleConfig, variantsMap);
    var trackStyles = getPartStyles('track', styleConfig, variantsMap);
    var innerTrackStyles = getPartStyles('innerTrack', styleConfig, variantsMap);
    var thumbStyles = getPartStyles('thumb', styleConfig, variantsMap);
    var systemProps = pick(props, systemPropNames$3);
    var inputProps = omit(props, systemPropNames$3);
    var isControlled = value !== undefined && originalOnChange !== undefined;
    var _c = React.useState(Number(value) || 0), stateValue = _c[0], setStateValue = _c[1];
    var percentage = ((stateValue - Number(min)) * 100) / (Number(max) - Number(min) || 100);
    // keep local state in sync with `value` prop
    React.useEffect(function () {
        if (isControlled) {
            setStateValue(Number(value));
        }
    }, [value, isControlled]);
    return (React.createElement(Wrapper$3, __assign({}, systemProps),
        React.createElement(InputPart$1, __assign({}, inputProps, { ref: forwardedRef, type: "range", value: value && String(stateValue), min: min, max: max, onChange: isControlled
                ? originalOnChange
                : composeEventHandlers(originalOnChange, function (event) {
                    return setStateValue(Number(event.target.value));
                }), sliderStyles: sliderStyles, thumbStyles: thumbStyles })),
        React.createElement(TrackPart, { trackStyles: trackStyles },
            React.createElement(InnerTrackPart, { innerTrackStyles: innerTrackStyles, style: { width: percentage + "%" } }))));
});
Slider.displayName = 'Slider';
Slider.defaultProps = {
    step: '1',
};
var Wrapper$3 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    display: 'flex',
}, 
// add system support
systemProps$m);
var InputPart$1 = styled('input').attrs({ 'data-part-id': 'slider' })(
// reset styles
cssReset('input'), 
// functional styles
{
    position: 'relative',
    zIndex: 1,
    '&:disabled': { pointerEvents: 'none' },
}, 
// apply slider style config
function (_a) {
    var _b = _a.sliderStyles, sliderStyles = _b === void 0 ? {} : _b;
    var normal = sliderStyles.normal, hover = sliderStyles.hover, focus = sliderStyles.focus, active = sliderStyles.active, disabled = sliderStyles.disabled;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active, '&:disabled': disabled });
}, 
// apply thumb style config
function (_a) {
    var _b = _a.thumbStyles, thumbStyles = _b === void 0 ? {} : _b;
    var normal = thumbStyles.normal;
    return {
        '&::-webkit-slider-thumb': normal,
        '&::-moz-range-thumb': normal,
    };
});
InputPart$1.displayName = 'InputPart';
var TrackPart = styled('div').attrs({ 'data-part-id': 'track' })(
// functional styles
{
    position: 'absolute',
    left: 0,
    top: '50%',
    right: 0,
    zIndex: 0,
    transform: 'translateY(-50%)',
}, 
// apply style config
function (_a) {
    var _b = _a.trackStyles, trackStyles = _b === void 0 ? {} : _b;
    return trackStyles.normal;
});
TrackPart.displayName = 'TrackPart';
var InnerTrackPart = styled('div').attrs({ 'data-part-id': 'innerTrack' })(
// functional styles
{
    height: '100%',
}, 
// apply style config
function (_a) {
    var _b = _a.innerTrackStyles, innerTrackStyles = _b === void 0 ? {} : _b;
    return innerTrackStyles.normal;
});
InnerTrackPart.displayName = 'InnerTrackPart';

var systemProps$n = boxSystemProps;
var systemPropNames$4 = boxSystemPropNames;
var Switch = React.forwardRef(function Switch(props, forwardedRef) {
    var _a, _b;
    var className = props.className, style = props.style, styleConfig = props.styleConfig;
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var switchStyles = getPartStyles('switch', styleConfig, variantsMap);
    var thumbStyles = getPartStyles('thumb', styleConfig, variantsMap);
    var systemProps = pick(props, systemPropNames$4);
    var inputProps = omit(props, systemPropNames$4);
    var switchPartRef = React.useRef(null);
    var thumbPartRef = React.useRef(null);
    var switchPartSize = useSize({ refToObserve: switchPartRef, isObserving: true });
    var thumbPartSize = useSize({ refToObserve: thumbPartRef, isObserving: true });
    var biggestHeight = Math.max((_a = switchPartSize === null || switchPartSize === void 0 ? void 0 : switchPartSize.height) !== null && _a !== void 0 ? _a : 0, (_b = thumbPartSize === null || thumbPartSize === void 0 ? void 0 : thumbPartSize.height) !== null && _b !== void 0 ? _b : 0);
    var height = biggestHeight === 0 ? undefined : biggestHeight;
    return (React.createElement(Wrapper$4, __assign({ className: className, style: __assign(__assign({}, style), { height: height }) }, systemProps),
        React.createElement(Input$3, __assign({}, inputProps, { type: "checkbox", ref: forwardedRef })),
        React.createElement(SwitchPart, { ref: switchPartRef, switchStyles: switchStyles },
            React.createElement(ThumbPart, { ref: thumbPartRef, thumbStyles: thumbStyles }))));
});
Switch.displayName = 'Switch';
var Wrapper$4 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
    verticalAlign: 'middle',
    position: 'relative',
}, 
// add system support
systemProps$n);
var Input$3 = styled('input')(
// reset styles
cssReset('input'), 
// functional styles
{
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    zIndex: 1,
    opacity: 0,
    '&:disabled': { pointerEvents: 'none' },
});
var SwitchPart = styled('div').attrs({ 'data-part-id': 'switch' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    zIndex: 0,
    display: 'flex',
    alignItems: 'center',
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.switchStyles, switchStyles = _c === void 0 ? {} : _c;
    var normal = switchStyles.normal, hover = switchStyles.hover, focus = switchStyles.focus, active = switchStyles.active, checked = switchStyles.checked, disabled = switchStyles.disabled;
    return __assign(__assign({}, normal), (_b = {}, _b[Input$3 + ":hover + &"] = hover, _b[Input$3 + ":focus + &"] = focus, _b[Input$3 + ":active + &"] = active, _b[Input$3 + ":checked + &"] = checked, _b[Input$3 + ":disabled + &"] = disabled, _b));
});
SwitchPart.displayName = 'SwitchPart';
var ThumbPart = styled('div').attrs({ 'data-part-id': 'thumb' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b = _a.thumbStyles, thumbStyles = _b === void 0 ? {} : _b;
    return thumbStyles.normal;
});
ThumbPart.displayName = 'ThumbPart';

var systemProps$o = boxSystemProps;
var systemPropNames$5 = boxSystemPropNames;
var SwitchContained = React.forwardRef(function SwitchContained(props, forwardedRef) {
    var _a, _b, _c;
    var className = props.className, style = props.style, styleConfig = props.styleConfig, _d = props.gap, gap = _d === void 0 ? 1 : _d;
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var switchStyles = getPartStyles('switch', styleConfig, variantsMap);
    var thumbStyles = getPartStyles('thumb', styleConfig, variantsMap);
    var systemProps = pick(props, systemPropNames$5);
    var inputProps = omit(props, systemPropNames$5);
    var switchPartRef = React.useRef(null);
    var thumbPartRef = React.useRef(null);
    var switchPartSize = useSize({ refToObserve: switchPartRef, isObserving: true });
    var thumbPartSize = useSize({ refToObserve: thumbPartRef, isObserving: true });
    var switchWidth = (_a = switchPartSize === null || switchPartSize === void 0 ? void 0 : switchPartSize.width) !== null && _a !== void 0 ? _a : 0;
    var switchHeight = (_b = switchPartSize === null || switchPartSize === void 0 ? void 0 : switchPartSize.height) !== null && _b !== void 0 ? _b : 0;
    var thumbWidth = (_c = thumbPartSize === null || thumbPartSize === void 0 ? void 0 : thumbPartSize.width) !== null && _c !== void 0 ? _c : 0;
    var thumbHeight = switchHeight - gap * 2;
    var height = switchHeight === 0 ? undefined : switchHeight;
    return (React.createElement(Wrapper$5, __assign({ className: className, style: __assign(__assign({}, style), { height: height }) }, systemProps),
        React.createElement(Input$4, __assign({}, inputProps, { type: "checkbox", ref: forwardedRef })),
        React.createElement(SwitchPart$1, { ref: switchPartRef, switchStyles: switchStyles },
            React.createElement(ThumbPart$1, { ref: thumbPartRef, thumbStyles: thumbStyles, checkedOffset: switchWidth - gap * 2 - thumbWidth, style: { height: thumbHeight, marginLeft: gap } }))));
});
SwitchContained.displayName = 'SwitchContained';
var Wrapper$5 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
    verticalAlign: 'middle',
    position: 'relative',
}, 
// add system support
systemProps$o);
var Input$4 = styled('input')(
// reset styles
cssReset('input'), 
// functional styles
{
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    zIndex: 1,
    opacity: 0,
    '&:disabled': { pointerEvents: 'none' },
});
var SwitchPart$1 = styled('div').attrs({ 'data-part-id': 'switch' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    zIndex: 0,
    display: 'flex',
    alignItems: 'center',
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.switchStyles, switchStyles = _c === void 0 ? {} : _c;
    var normal = switchStyles.normal, hover = switchStyles.hover, focus = switchStyles.focus, active = switchStyles.active, checked = switchStyles.checked, disabled = switchStyles.disabled;
    return __assign(__assign({}, normal), (_b = {}, _b[Input$4 + ":hover + &"] = hover, _b[Input$4 + ":focus + &"] = focus, _b[Input$4 + ":active + &"] = active, _b[Input$4 + ":checked + &"] = checked, _b[Input$4 + ":disabled + &"] = disabled, _b));
});
SwitchPart$1.displayName = 'SwitchPart';
var ThumbPart$1 = styled('div').attrs({ 'data-part-id': 'thumb' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b;
    var _c = _a.thumbStyles, thumbStyles = _c === void 0 ? {} : _c, checkedOffset = _a.checkedOffset;
    return (__assign(__assign({}, thumbStyles.normal), (_b = {}, _b[Input$4 + ":checked + " + SwitchPart$1 + " &"] = {
        transform: "translate3d(" + checkedOffset + "px, 0, 0)",
    }, _b)));
});
ThumbPart$1.displayName = 'ThumbPart';

var systemProps$p = boxSystemProps;
var systemPropNames$6 = boxSystemPropNames;
var SwitchSlider = React.forwardRef(function SwitchSlider(props, forwardedRef) {
    var _a, _b, _c, _d;
    var className = props.className, style = props.style, styleConfig = props.styleConfig;
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var switchStyles = getPartStyles('switch', styleConfig, variantsMap);
    var thumbStyles = getPartStyles('thumb', styleConfig, variantsMap);
    var systemProps = pick(props, systemPropNames$6);
    var inputProps = omit(props, systemPropNames$6);
    var switchPartRef = React.useRef(null);
    var thumbPartRef = React.useRef(null);
    var switchPartSize = useSize({ refToObserve: switchPartRef, isObserving: true });
    var thumbPartSize = useSize({ refToObserve: thumbPartRef, isObserving: true });
    var biggestHeight = Math.max((_a = switchPartSize === null || switchPartSize === void 0 ? void 0 : switchPartSize.height) !== null && _a !== void 0 ? _a : 0, (_b = thumbPartSize === null || thumbPartSize === void 0 ? void 0 : thumbPartSize.height) !== null && _b !== void 0 ? _b : 0);
    var switchWidth = (_c = switchPartSize === null || switchPartSize === void 0 ? void 0 : switchPartSize.width) !== null && _c !== void 0 ? _c : 0;
    var thumbWidth = (_d = thumbPartSize === null || thumbPartSize === void 0 ? void 0 : thumbPartSize.width) !== null && _d !== void 0 ? _d : 0;
    var height = biggestHeight === 0 ? undefined : biggestHeight;
    return (React.createElement(Wrapper$6, __assign({ className: className, style: __assign(__assign({}, style), { height: height }) }, systemProps),
        React.createElement(Input$5, __assign({}, inputProps, { type: "checkbox", ref: forwardedRef })),
        React.createElement(SwitchPart$2, { ref: switchPartRef, switchStyles: switchStyles },
            React.createElement(ThumbPart$2, { ref: thumbPartRef, thumbStyles: thumbStyles, checkedOffset: switchWidth - thumbWidth }))));
});
SwitchSlider.displayName = 'SwitchSlider';
var Wrapper$6 = styled('div')(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
    verticalAlign: 'middle',
    position: 'relative',
}, 
// add system support
systemProps$p);
var Input$5 = styled('input')(
// reset styles
cssReset('input'), 
// functional styles
{
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    zIndex: 1,
    opacity: 0,
    '&:disabled': { pointerEvents: 'none' },
});
var SwitchPart$2 = styled('div').attrs({ 'data-part-id': 'switch' })(
// reset styles
cssReset('div'), 
// functional styles
{
    position: 'relative',
    zIndex: 0,
    display: 'flex',
    alignItems: 'center',
}, 
// apply style config
function (_a) {
    var _b;
    var _c = _a.switchStyles, switchStyles = _c === void 0 ? {} : _c;
    var normal = switchStyles.normal, hover = switchStyles.hover, focus = switchStyles.focus, active = switchStyles.active, checked = switchStyles.checked, disabled = switchStyles.disabled;
    return __assign(__assign({}, normal), (_b = {}, _b[Input$5 + ":hover + &"] = hover, _b[Input$5 + ":focus + &"] = focus, _b[Input$5 + ":active + &"] = active, _b[Input$5 + ":checked + &"] = checked, _b[Input$5 + ":disabled + &"] = disabled, _b));
});
SwitchPart$2.displayName = 'SwitchPart';
var ThumbPart$2 = styled('div').attrs({ 'data-part-id': 'thumb' })(
// reset styles
cssReset('div'), 
// apply style config
function (_a) {
    var _b;
    var _c = _a.thumbStyles, thumbStyles = _c === void 0 ? {} : _c, checkedOffset = _a.checkedOffset;
    return (__assign(__assign({}, thumbStyles.normal), (_b = {}, _b[Input$5 + ":checked + " + SwitchPart$2 + " &"] = {
        transform: "translate3d(" + checkedOffset + "px, 0, 0)",
    }, _b)));
});
ThumbPart$2.displayName = 'ThumbPart';

var systemProps$q = boxSystemProps;
var TableStylingContext = React.createContext({});
var Table = React.forwardRef(function Table(props, forwardedRef) {
    var styleConfig = props.styleConfig, tableProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var tableStyles = getPartStyles('table', styleConfig, variantsMap);
    var theadStyles = getPartStyles('thead', styleConfig, variantsMap);
    var tfootStyles = getPartStyles('tfoot', styleConfig, variantsMap);
    var tbodyStyles = getPartStyles('tbody', styleConfig, variantsMap);
    var trStyles = getPartStyles('tr', styleConfig, variantsMap);
    var thStyles = getPartStyles('th', styleConfig, variantsMap);
    var tdStyles = getPartStyles('td', styleConfig, variantsMap);
    return (React.createElement(TableStylingContext.Provider, { value: { theadStyles: theadStyles, tfootStyles: tfootStyles, tbodyStyles: tbodyStyles, trStyles: trStyles, thStyles: thStyles, tdStyles: tdStyles } },
        React.createElement(TablePart, __assign({}, tableProps, { ref: forwardedRef, tableStyles: tableStyles }))));
});
Table.displayName = 'Table';
var TablePart = styled('table').attrs({ 'data-part-id': 'table' })(
// reset styles
cssReset('table'), 
// functional styles
{
    borderCollapse: 'collapse',
    width: '100%',
}, 
// apply style config
function (_a) {
    var _b = _a.tableStyles, tableStyles = _b === void 0 ? {} : _b;
    return tableStyles.normal;
}, 
// add system support
systemProps$q);
TablePart.displayName = 'TablePart';
var Thead = React.forwardRef(function (props, forwardedRef) {
    var theadStyles = React.useContext(TableStylingContext).theadStyles;
    return React.createElement(TheadPart, __assign({}, props, { ref: forwardedRef, theadStyles: theadStyles }));
});
Thead.displayName = 'Thead';
var TheadPart = styled('thead').attrs({ 'data-part-id': 'thead' })(
// reset styles
cssReset('thead'), 
// apply style config
function (_a) {
    var _b = _a.theadStyles, theadStyles = _b === void 0 ? {} : _b;
    return theadStyles.normal;
}, 
// add system support
systemProps$q);
TheadPart.displayName = 'TheadPart';
var Tfoot = React.forwardRef(function Tfoot(props, forwardedRef) {
    var tfootStyles = React.useContext(TableStylingContext).tfootStyles;
    return React.createElement(TfootPart, __assign({}, props, { ref: forwardedRef, tfootStyles: tfootStyles }));
});
Tfoot.displayName = 'Tfoot';
var TfootPart = styled('tfoot').attrs({ 'data-part-id': 'tfoot' })(
// reset styles
cssReset('tfoot'), 
// apply style config
function (_a) {
    var _b = _a.tfootStyles, tfootStyles = _b === void 0 ? {} : _b;
    return tfootStyles.normal;
}, 
// add system support
systemProps$q);
TfootPart.displayName = 'TfootPart';
var Tbody = React.forwardRef(function Tbody(props, forwardedRef) {
    var tbodyStyles = React.useContext(TableStylingContext).tbodyStyles;
    return React.createElement(TbodyPart, __assign({}, props, { ref: forwardedRef, tbodyStyles: tbodyStyles }));
});
Tbody.displayName = 'Tbody';
var TbodyPart = styled('tbody').attrs({ 'data-part-id': 'tbody' })(
// reset styles
cssReset('tbody'), 
// apply style config
function (_a) {
    var _b = _a.tbodyStyles, tbodyStyles = _b === void 0 ? {} : _b;
    return tbodyStyles.normal;
}, 
// add system support
systemProps$q);
TbodyPart.displayName = 'TbodyPart';
var Tr = React.forwardRef(function Tr(props, forwardedRef) {
    var trStyles = React.useContext(TableStylingContext).trStyles;
    return React.createElement(TrPart, __assign({}, props, { ref: forwardedRef, trStyles: trStyles }));
});
Tr.displayName = 'Tr';
var TrPart = styled('tr').attrs({ 'data-part-id': 'tr' })(
// reset styles
cssReset('tr'), 
// apply style config
function (_a) {
    var _b = _a.trStyles, trStyles = _b === void 0 ? {} : _b;
    return trStyles.normal;
}, 
// add system support
systemProps$q);
TrPart.displayName = 'TrPart';
var Th = React.forwardRef(function Th(props, forwardedRef) {
    var thStyles = React.useContext(TableStylingContext).thStyles;
    return React.createElement(ThPart, __assign({}, props, { ref: forwardedRef, thStyles: thStyles }));
});
Th.displayName = 'Th';
var ThPart = styled('th').attrs({ 'data-part-id': 'th' })(
// reset styles
cssReset('th'), 
// apply style config
function (_a) {
    var _b = _a.thStyles, thStyles = _b === void 0 ? {} : _b;
    return thStyles.normal;
}, 
// add system support
systemProps$q);
ThPart.displayName = 'ThPart';
var Td = React.forwardRef(function Td(props, forwardedRef) {
    var tdStyles = React.useContext(TableStylingContext).tdStyles;
    return React.createElement(TdPart, __assign({}, props, { ref: forwardedRef, tdStyles: tdStyles }));
});
Td.displayName = 'Td';
var TdPart = styled('td').attrs({ 'data-part-id': 'td' })(
// reset styles
cssReset('td'), 
// apply style config
function (_a) {
    var _b = _a.tdStyles, tdStyles = _b === void 0 ? {} : _b;
    return tdStyles.normal;
}, 
// add system support
systemProps$q);
TdPart.displayName = 'TdPart';

function useRovingTabIndex(_a) {
    var id = _a.id, isSelected = _a.isSelected, elementRef = _a.elementRef, originalOnFocus = _a.onFocus, originalOnKeyDown = _a.onKeyDown;
    var _b = useRovingTabIndexStateContext(), orientation = _b.orientation, currentTabStopId = _b.currentTabStopId;
    var dispatch = useRovingTabIndexDispatchContext();
    var shouldBeFocused = currentTabStopId === id;
    var isTabbable = isSelected;
    /**
     * Handle registration/unregistration of tab stops
     */
    React.useEffect(function () {
        dispatch({ type: 'register', tabStop: { id: id, ref: elementRef } });
        return function () {
            dispatch({ type: 'unregister', id: id });
        };
    }, [dispatch, elementRef, id]);
    /**
     * Handle focusing the tab stop's element
     */
    React.useEffect(function () {
        var _a;
        if (shouldBeFocused) {
            (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }, [elementRef, shouldBeFocused]);
    var getDirection = React.useCallback(function (event) {
        var isHorizontal = orientation !== 'vertical';
        if (isHorizontal) {
            if (event.key === 'ArrowRight')
                return 'next';
            if (event.key === 'ArrowLeft')
                return 'previous';
        }
        else {
            if (event.key === 'ArrowDown')
                return 'next';
            if (event.key === 'ArrowUp')
                return 'previous';
        }
        return null;
    }, [orientation]);
    var handleFocus = React.useCallback(function (event) { return dispatch({ type: 'moveFocus', id: id }); }, [
        dispatch,
        id,
    ]);
    var handleKeyDown = React.useCallback(function (event) {
        var direction = getDirection(event);
        if (direction === 'next') {
            event.preventDefault();
            dispatch({ type: 'moveFocusToNext' });
        }
        else if (direction === 'previous') {
            event.preventDefault();
            dispatch({ type: 'moveFocusToPrevious' });
        }
        else if (event.key === 'Home') {
            event.preventDefault();
            dispatch({ type: 'moveFocusToFirst' });
        }
        else if (event.key === 'End') {
            event.preventDefault();
            dispatch({ type: 'moveFocusToLast' });
        }
    }, [dispatch, getDirection]);
    return {
        onFocus: composeEventHandlers(originalOnFocus, handleFocus, {
            checkForDefaultPrevented: false,
        }),
        onKeyDown: composeEventHandlers(originalOnKeyDown, handleKeyDown),
        tabIndex: isTabbable ? 0 : -1,
    };
}
function RovingTabIndexProvider(_a) {
    var children = _a.children, orientation = _a.orientation, _b = _a.shouldLoop, shouldLoop = _b === void 0 ? true : _b;
    var _c = React.useReducer(reducer, {
        orientation: orientation,
        shouldLoop: shouldLoop,
        tabStops: [],
        currentTabStopId: null,
    }), state = _c[0], dispatch = _c[1];
    // Sync `orientation` changes
    React.useEffect(function () {
        dispatch({ type: 'updateOrientation', orientation: orientation });
    }, [orientation, dispatch]);
    // Sync `shouldLoop` changes
    React.useEffect(function () {
        dispatch({ type: 'updateShouldLoop', shouldLoop: shouldLoop });
    }, [shouldLoop, dispatch]);
    return (React.createElement(RovingTabIndexStateContext.Provider, { value: state },
        React.createElement(RovingTabIndexDispatchContext.Provider, { value: dispatch }, children)));
}
function reducer(state, action) {
    var _a, _b, _c, _d;
    switch (action.type) {
        case 'register': {
            var newTabStop_1 = action.tabStop;
            if (state.tabStops.length === 0) {
                return __assign(__assign({}, state), { tabStops: [newTabStop_1] });
            }
            var isAlreadyRegistered = state.tabStops.map(function (tabStop) { return tabStop.id; }).includes(newTabStop_1.id);
            if (isAlreadyRegistered) {
                console.warn(newTabStop_1.id + " tab stop is already registered");
                return state;
            }
            var indexToInsertAt = state.tabStops.findIndex(function (tabStop) {
                if (!tabStop.ref.current || !newTabStop_1.ref.current)
                    return false;
                // Return true if the new tab stop's element is located earlier in the DOM
                // than each tab stop's element, else false:
                return Boolean(
                // See: https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
                tabStop.ref.current.compareDocumentPosition(newTabStop_1.ref.current) & Node.DOCUMENT_POSITION_PRECEDING);
            });
            // findIndex returns -1 when `newTabStop` should be inserted at the end of tabStops
            // (the compareDocumentPosition test always returns false in that case).
            if (indexToInsertAt === -1) {
                indexToInsertAt = state.tabStops.length;
            }
            return __assign(__assign({}, state), { tabStops: arrayInsert(state.tabStops, newTabStop_1, indexToInsertAt) });
        }
        case 'unregister': {
            var tabStopIdToRemove_1 = action.id;
            var filteredTabStops = state.tabStops.filter(function (tabStop) { return tabStop.id !== tabStopIdToRemove_1; });
            if (filteredTabStops.length === state.tabStops.length) {
                console.warn(tabStopIdToRemove_1 + " tab stop is already unregistered");
                return state;
            }
            return __assign(__assign({}, state), { tabStops: filteredTabStops });
        }
        case 'moveFocus': {
            var tabStopIdToFocus_1 = action.id;
            if (tabStopIdToFocus_1 === null) {
                return __assign(__assign({}, state), { currentTabStopId: null });
            }
            var index = state.tabStops.findIndex(function (tabStop) { return tabStop.id === tabStopIdToFocus_1; });
            // The item doesn't exist, so we do nothing
            if (index === -1) {
                return state;
            }
            return __assign(__assign({}, state), { currentTabStopId: state.tabStops[index].id });
        }
        case 'moveFocusToNext': {
            if (state.currentTabStopId == null) {
                return reducer(state, { type: 'moveFocus', id: (_a = state.tabStops[0].id) !== null && _a !== void 0 ? _a : null });
            }
            var index = state.tabStops.findIndex(function (tabStop) { return tabStop.id === state.currentTabStopId; });
            var tabStopCount = state.tabStops.length;
            var nextIndex = state.shouldLoop ? (index + 1) % tabStopCount : clamp(index + 1, [0, tabStopCount - 1]);
            return reducer(state, { type: 'moveFocus', id: (_b = state.tabStops[nextIndex].id) !== null && _b !== void 0 ? _b : null });
        }
        case 'moveFocusToPrevious': {
            var stateWithReversedTabStops = __assign(__assign({}, state), { tabStops: state.tabStops.slice().reverse() });
            var currentTabStopId = reducer(stateWithReversedTabStops, { type: 'moveFocusToNext' }).currentTabStopId;
            return __assign(__assign({}, state), { currentTabStopId: currentTabStopId });
        }
        case 'moveFocusToFirst': {
            var firstTabStop = state.tabStops[0];
            return reducer(state, { type: 'moveFocus', id: (_c = firstTabStop.id) !== null && _c !== void 0 ? _c : null });
        }
        case 'moveFocusToLast': {
            var lastTabStop = state.tabStops[state.tabStops.length - 1];
            return reducer(state, { type: 'moveFocus', id: (_d = lastTabStop.id) !== null && _d !== void 0 ? _d : null });
        }
        case 'updateOrientation': {
            return __assign(__assign({}, state), { orientation: action.orientation });
        }
        case 'updateShouldLoop': {
            return __assign(__assign({}, state), { shouldLoop: action.shouldLoop });
        }
        default:
            throw new Error();
    }
}
var RovingTabIndexStateContext = React.createContext(undefined);
var RovingTabIndexDispatchContext = React.createContext(undefined);
function useRovingTabIndexStateContext() {
    var context = React.useContext(RovingTabIndexStateContext);
    if (context === undefined) {
        throw new Error('`useRovingTabIndexStateContext` must be used within a RovingTabIndexProvider');
    }
    return context;
}
function useRovingTabIndexDispatchContext() {
    var context = React.useContext(RovingTabIndexDispatchContext);
    if (context === undefined) {
        throw new Error('`useRovingTabIndexDispatchContext` must be used within a RovingTabIndexProvider');
    }
    return context;
}

/**
 * This hook can be used to create an accessible mouse down handler
 * which retains keyboard accessibility (that you normally get with click events).
 */
function useAccessibleMouseDown(handler, _a) {
    var isDisabled = _a.isDisabled, originalOnMouseDown = _a.onMouseDown, originalOnKeyDown = _a.onKeyDown;
    var handleMouseDown = React.useCallback(function (event) {
        if (isDisabled) {
            // prevent focus from happening
            event.preventDefault();
            return;
        }
        // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)
        // but not when the control key is pressed (avoiding MacOS right click)
        if (event.button === 0 && event.ctrlKey === false) {
            handler(event);
        }
    }, [handler, isDisabled]);
    var handleKeyDown = React.useCallback(function (event) {
        if (isDisabled)
            return;
        if (event.key === ' ' || event.key === 'Enter') {
            // prevent active state to be stuck in case focus moves somewhere else before mouseUp
            event.preventDefault();
            handler(event);
        }
    }, [handler, isDisabled]);
    return {
        onMouseDown: composeEventHandlers(originalOnMouseDown, handleMouseDown),
        onKeyDown: composeEventHandlers(originalOnKeyDown, handleKeyDown),
    };
}

var systemProps$r = boxSystemProps;
var TabsContext = React.createContext({
    tabsId: '',
});
var TabsStylingContext = React.createContext({});
var Tabs = React.forwardRef(function Tabs(props, forwardedRef) {
    var children = props.children, id = props.id, selectedIdProp = props.selectedId, onSelect = props.onSelect, defaultSelectedId = props.defaultSelectedId, _a = props.orientation, orientation = _a === void 0 ? 'horizontal' : _a, _b = props.activationMode, activationMode = _b === void 0 ? 'automatic' : _b, _c = props.shouldLoop, shouldLoop = _c === void 0 ? true : _c, styleConfig = props.styleConfig, tabsProps = __rest(props, ["children", "id", "selectedId", "onSelect", "defaultSelectedId", "orientation", "activationMode", "shouldLoop", "styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    // NOTE: including `orientation` as a potential variant prop
    var variantsMap = makeVariantsMap(__assign(__assign({}, tabsProps), { orientation: orientation }), variantNames);
    var tabsStyles = getPartStyles('tabs', styleConfig, variantsMap);
    var listStyles = getPartStyles('list', styleConfig, variantsMap);
    var tabStyles = getPartStyles('tab', styleConfig, variantsMap);
    var panelStyles = getPartStyles('panel', styleConfig, variantsMap);
    var generatedTabsId = "tabs-" + useId();
    var tabsId = id || generatedTabsId;
    var _d = useControlledState({
        prop: selectedIdProp,
        onChange: onSelect,
        defaultProp: defaultSelectedId,
    }), selectedId = _d[0], setSelectedId = _d[1];
    return (React.createElement(TabsContext.Provider, { value: {
            tabsId: tabsId,
            selectedId: selectedId,
            setSelectedId: setSelectedId,
            orientation: orientation,
            activationMode: activationMode,
            shouldLoop: shouldLoop,
        } },
        React.createElement(TabsStylingContext.Provider, { value: { listStyles: listStyles, tabStyles: tabStyles, panelStyles: panelStyles } },
            React.createElement(TabsPart, __assign({}, tabsProps, { ref: forwardedRef, id: tabsId, orientation: orientation, tabsStyles: tabsStyles }), children))));
});
Tabs.displayName = 'Tabs';
var TabList = React.forwardRef(function TabList(props, forwardedRef) {
    var _a = React.useContext(TabsContext), orientation = _a.orientation, shouldLoop = _a.shouldLoop;
    var listStyles = React.useContext(TabsStylingContext).listStyles;
    return (React.createElement(RovingTabIndexProvider, { orientation: orientation, shouldLoop: shouldLoop },
        React.createElement(TabListPart, __assign({}, props, { 
            // accessibility
            role: "tablist", "aria-orientation": orientation, 
            // other props
            ref: forwardedRef, tabListStyles: listStyles }))));
});
TabList.displayName = 'TabList';
var Tab = React.forwardRef(function Tab(props, forwardedRef) {
    var id = props.id, disabled = props.disabled, originalOnMouseDown = props.onMouseDown, originalOnKeyDown = props.onKeyDown, originalOnFocus = props.onFocus, tabProps = __rest(props, ["id", "disabled", "onMouseDown", "onKeyDown", "onFocus"]);
    var _a = React.useContext(TabsContext), tabsId = _a.tabsId, selectedId = _a.selectedId, setSelectedId = _a.setSelectedId, activationMode = _a.activationMode;
    var tabStyles = React.useContext(TabsStylingContext).tabStyles;
    var tabId = makeTabId(tabsId, id);
    var tabPanelId = makeTabPanelId(tabsId, id);
    var isSelected = id === selectedId;
    var ref = React.useRef(null);
    var composedRef = useComposedRefs(forwardedRef, ref);
    var selectTab = React.useCallback(function () { return setSelectedId === null || setSelectedId === void 0 ? void 0 : setSelectedId(id); }, [id, setSelectedId]);
    var _b = useRovingTabIndex({
        id: tabId,
        isSelected: Boolean(isSelected),
        elementRef: ref,
        onFocus: originalOnFocus,
        onKeyDown: originalOnKeyDown,
    }), rovingTabIndexFocusHandler = _b.onFocus, rovingTabIndexKeyDownHandler = _b.onKeyDown, tabIndex = _b.tabIndex;
    // handle "automatic" activation if necessary
    // ie. activate tab following focus
    function handleFocus() {
        var isAutomaticActivation = activationMode !== 'manual';
        if (!isSelected && !disabled && isAutomaticActivation) {
            selectTab();
        }
    }
    return (React.createElement(TabPart, __assign({}, tabProps, { 
        // accessibility
        id: tabId, role: "tab", "aria-selected": isSelected, "aria-controls": tabPanelId, "aria-disabled": disabled ? true : undefined, tabIndex: tabIndex, onFocus: composeEventHandlers(rovingTabIndexFocusHandler, handleFocus, {
            checkForDefaultPrevented: false,
        }) }, useAccessibleMouseDown(selectTab, {
        isDisabled: disabled,
        onMouseDown: originalOnMouseDown,
        onKeyDown: rovingTabIndexKeyDownHandler,
    }), { 
        // other props
        ref: composedRef, isSelected: isSelected, tabStyles: tabStyles })));
});
Tab.displayName = 'Tab';
var TabPanel = React.forwardRef(function TabPanel(props, forwardedRef) {
    var id = props.id, tabPanelProps = __rest(props, ["id"]);
    var _a = React.useContext(TabsContext), tabsId = _a.tabsId, selectedId = _a.selectedId;
    var panelStyles = React.useContext(TabsStylingContext).panelStyles;
    var tabId = makeTabId(tabsId, id);
    var tabPanelId = makeTabPanelId(tabsId, id);
    var isSelected = id === selectedId;
    return (React.createElement(TabPanelPart, __assign({}, tabPanelProps, { 
        // accessibility
        id: tabPanelId, role: "tabpanel", "aria-labelledby": tabId, tabIndex: 0, hidden: !isSelected, style: { display: isSelected ? undefined : 'none' }, 
        // other props
        ref: forwardedRef, tabPanelStyles: panelStyles })));
});
TabPanel.displayName = 'TabPanel';
var TabsPart = styled('div').attrs({ 'data-part-id': 'tabs' })(
// reset styles
cssReset('div'), 
// functional styles
function (_a) {
    var orientation = _a.orientation;
    return ({
        display: 'flex',
        flexDirection: orientation === 'vertical' ? 'row' : 'column',
    });
}, 
// apply style config
function (_a) {
    var _b = _a.tabsStyles, tabsStyles = _b === void 0 ? {} : _b;
    return tabsStyles.normal;
}, 
// add system support
systemProps$r);
TabsPart.displayName = 'TabsPart';
var TabListPart = styled('div').attrs({ 'data-part-id': 'list' })(
// reset styles
cssReset('div'), 
// functional styles
function (props) { return ({
    flexShrink: 0,
    display: 'flex',
    flexDirection: props['aria-orientation'] === 'vertical' ? 'column' : 'row',
}); }, 
// apply style config
function (_a) {
    var _b = _a.tabListStyles, tabListStyles = _b === void 0 ? {} : _b;
    return tabListStyles.normal;
}, 
// add system support
systemProps$r);
TabListPart.displayName = 'TabListPart';
var TabPart = styled('div').attrs({ 'data-part-id': 'tab' })(
// reset styles
cssReset('div'), getFocusableResetStyles(), 
// functional styles
{
    flexShrink: 0,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    lineHeight: '1',
    cursor: 'default',
    whiteSpace: 'nowrap',
    // enable overlapping adjacent tabs via z-index
    position: 'relative',
}, 
// apply style config
function (_a) {
    var _b = _a.tabStyles, tabStyles = _b === void 0 ? {} : _b, isSelected = _a.isSelected;
    var normal = tabStyles.normal, first = tabStyles.first, last = tabStyles.last, hover = tabStyles.hover, focus = tabStyles.focus, active = tabStyles.active, selected = tabStyles.selected, disabled = tabStyles.disabled;
    return __assign(__assign(__assign(__assign({}, normal), { '&:first-child': first, '&:last-child': last, '&:not([aria-disabled]):hover': hover, '&:focus': focus, '&:not([aria-disabled]):active': active }), (isSelected ? selected : {})), { '&[aria-disabled]': disabled });
}, 
// add system support
systemProps$r);
TabPart.displayName = 'TabPart';
var TabPanelPart = styled('div').attrs({ 'data-part-id': 'panel' })(
// reset styles
cssReset('div'), getFocusableResetStyles(), 
// functional styles
{
    flexGrow: 1,
}, 
// apply style config
function (_a) {
    var _b = _a.tabPanelStyles, tabPanelStyles = _b === void 0 ? {} : _b;
    var normal = tabPanelStyles.normal, focus = tabPanelStyles.focus;
    return __assign(__assign({}, normal), { '&:focus': focus });
}, 
// add system support
systemProps$r);
TabPanelPart.displayName = 'TabPanelPart';
function makeTabId(tabsId, tabId) {
    return tabsId + "-tab-" + tabId;
}
function makeTabPanelId(tabsId, tabId) {
    return tabsId + "-tabPanel-" + tabId;
}

var systemProps$s = boxSystemProps;
var Text = React.forwardRef(function Text(props, forwardedRef) {
    var styleConfig = props.styleConfig, textProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var textStyles = getPartStyles('text', styleConfig, variantsMap);
    return React.createElement(TextPart, __assign({}, textProps, { ref: forwardedRef, textStyles: textStyles }));
});
Text.displayName = 'Text';
var TextPart = styled('span').attrs({ 'data-part-id': 'text' })(
// reset styles
cssReset('span'), 
// apply style config
function (_a) {
    var _b = _a.textStyles, textStyles = _b === void 0 ? {} : _b;
    return textStyles.normal;
}, 
// add system support
systemProps$s);
TextPart.displayName = 'TextPart';

var systemProps$t = boxSystemProps;
var Textarea = React.forwardRef(function Textarea(props, forwardedRef) {
    var styleConfig = props.styleConfig, textareaProps = __rest(props, ["styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var textareaStyles = getPartStyles('textarea', styleConfig, variantsMap);
    var placeholderStyles = getPartStyles('placeholder', styleConfig, variantsMap);
    return (React.createElement(TextareaPart, __assign({}, textareaProps, { ref: forwardedRef, textareaStyles: textareaStyles, placeholderStyles: placeholderStyles })));
});
Textarea.displayName = 'Textarea';
var TextareaPart = styled('textarea').attrs({ 'data-part-id': 'textarea' })(
// reset styles
cssReset('textarea'), 
// functional styles
{
    width: '100%',
    resize: 'vertical',
    '&:disabled': { pointerEvents: 'none' },
}, 
// apply style config
function (_a) {
    var _b = _a.textareaStyles, textareaStyles = _b === void 0 ? {} : _b, _c = _a.placeholderStyles, placeholderStyles = _c === void 0 ? {} : _c;
    var normal = textareaStyles.normal, hover = textareaStyles.hover, focus = textareaStyles.focus, active = textareaStyles.active, readOnly = textareaStyles.readOnly, disabled = textareaStyles.disabled;
    return __assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active, '&:read-only': readOnly, '&:disabled': disabled, '&::-webkit-input-placeholder': placeholderStyles.normal, '&::-moz-placeholder': placeholderStyles.normal, '&:-ms-input-placeholder': placeholderStyles.normal });
}, 
// add system support
systemProps$t);
TextareaPart.displayName = 'TextareaPart';

var systemProps$u = boxSystemProps;
var ToggleButton = React.forwardRef(function ToggleButton(props, forwardedRef) {
    var isToggledProp = props.isToggled, _a = props.defaultIsToggled, defaultIsToggled = _a === void 0 ? false : _a, onToggle = props.onToggle, originalOnClick = props.onClick, styleConfig = props.styleConfig, buttonProps = __rest(props, ["isToggled", "defaultIsToggled", "onToggle", "onClick", "styleConfig"]);
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var buttonStyles = getPartStyles('button', styleConfig, variantsMap);
    var _b = useControlledState({
        prop: isToggledProp,
        onChange: onToggle,
        defaultProp: defaultIsToggled,
    }), isToggled = _b[0], setIsToggled = _b[1];
    return (React.createElement(ButtonPart$3, __assign({}, buttonProps, { 
        // accessibility
        type: "button", "aria-pressed": Boolean(isToggled), 
        // other props
        ref: forwardedRef, onClick: composeEventHandlers(originalOnClick, function () { return setIsToggled(!isToggled); }), isToggled: isToggled, buttonStyles: buttonStyles })));
});
ToggleButton.displayName = 'ToggleButton';
var ButtonPart$3 = styled('button').attrs({ 'data-part-id': 'button' })(
// reset styles
cssReset('button'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexBasis: 0,
    flexGrow: 1,
    lineHeight: '1',
    userSelect: 'none',
    whiteSpace: 'nowrap',
    '&:disabled': { pointerEvents: 'none' },
    // enable overlapping adjacent buttons via z-index
    position: 'relative',
}, 
// apply style config
function (_a) {
    var _b = _a.buttonStyles, buttonStyles = _b === void 0 ? {} : _b, isToggled = _a.isToggled;
    var normal = buttonStyles.normal, hover = buttonStyles.hover, focus = buttonStyles.focus, active = buttonStyles.active, toggled = buttonStyles.toggled, disabled = buttonStyles.disabled;
    return __assign(__assign(__assign(__assign({}, normal), { '&:hover': hover, '&:focus': focus, '&:active': active }), (isToggled ? toggled : {})), { '&:disabled': disabled });
}, 
// add system support
systemProps$u);
ButtonPart$3.displayName = 'ButtonPart';

var isProduction = process.env.NODE_ENV === 'production';
function createStateMachine(stateChart, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.debug, debug = _c === void 0 ? false : _c, _d = _b.warnOnUnknownTransitions, warnOnUnknownTransitions = _d === void 0 ? !isProduction : _d;
    var CURRENT_STATE = stateChart.initial;
    var CURRENT_CONTEXT = stateChart.context;
    var subscriptions = [];
    function subscribe(callback) {
        subscriptions.push(callback);
        return function () {
            subscriptions.splice(subscriptions.indexOf(callback), 1);
        };
    }
    function notify() {
        subscriptions.forEach(function (callback) { return callback(CURRENT_STATE, CURRENT_CONTEXT); });
    }
    var transition = function (event, context) {
        var stateDefinition = stateChart.states[CURRENT_STATE];
        // we cast to `State | undefined` because otherwise the type of `nextState`
        // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`
        // and would cause issue later when trying to grab `nextStateDefinition`
        // as it would conflict with the type of `StateChart.states` which is
        // `Record<State, StateDefinition<State, Event>>`
        var nextState = stateDefinition.on && stateDefinition.on[event];
        if (nextState === undefined) {
            if (warnOnUnknownTransitions) {
                console.warn("From state: \"" + CURRENT_STATE + "\", event \"" + event + "\" does not lead to any state");
            }
        }
        else {
            var previousState = CURRENT_STATE;
            var previousContext = CURRENT_CONTEXT;
            if (stateDefinition.onLeaveState) {
                stateDefinition.onLeaveState(transition);
            }
            var nextStateDefinition = stateChart.states[nextState];
            if (nextStateDefinition.onEnterState) {
                nextStateDefinition.onEnterState(transition);
            }
            CURRENT_STATE = nextState;
            if (context !== undefined) {
                CURRENT_CONTEXT = context;
            }
            if (debug) {
                console.log({
                    previousState: previousState,
                    previousContext: previousContext,
                    event: event,
                    state: CURRENT_STATE,
                    context: CURRENT_CONTEXT,
                });
            }
            notify();
        }
    };
    function getState() {
        return CURRENT_STATE;
    }
    function getContext() {
        return CURRENT_CONTEXT;
    }
    return {
        subscribe: subscribe,
        transition: transition,
        getState: getState,
        getContext: getContext,
    };
}

// How long the mouse needs to stop moving for the tooltip to open
var REST_THRESHOLD_DURATION$1 = 300;
// How much time does the user has to move from one tooltip to another without incurring the rest wait
var SKIP_REST_THRESHOLD_DURATION = 300;
var tooltipStateChart = {
    initial: 'CLOSED',
    context: { id: null },
    states: {
        CLOSED: {
            on: {
                mouseEntered: 'WAITING_FOR_REST',
                focused: 'OPEN',
            },
        },
        WAITING_FOR_REST: {
            onEnterState: startRestTimer,
            onLeaveState: clearRestTimer,
            on: {
                restTimerElapsed: 'OPEN',
                mouseMoved: 'WAITING_FOR_REST',
                mouseLeft: 'CLOSED',
                activated: 'DISMISSED',
                unmounted: 'CLOSED',
            },
        },
        OPEN: {
            on: {
                mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',
                mouseEntered: 'OPEN',
                mouseMoved: 'OPEN',
                activated: 'DISMISSED',
                blurred: 'CLOSED',
                targetMoved: 'CLOSED',
                unmounted: 'CLOSED',
            },
        },
        CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {
            onEnterState: startSkipRestTimer,
            onLeaveState: clearSkipRestTimer,
            on: {
                skipRestTimerElapsed: 'CLOSED',
                mouseEntered: 'OPEN',
                focused: 'OPEN',
                activated: 'DISMISSED',
                unmounted: 'CLOSED',
            },
        },
        DISMISSED: {
            on: {
                mouseLeft: 'CLOSED',
                blurred: 'CLOSED',
                unmounted: 'CLOSED',
            },
        },
    },
};
// The rest timer is used to check for the user "resting" a certain
// period of time over the target, before deciding to open the tooltip.
var restTimerId;
function startRestTimer(transition) {
    clearTimeout(restTimerId);
    restTimerId = window.setTimeout(function () { return transition('restTimerElapsed'); }, REST_THRESHOLD_DURATION$1);
}
function clearRestTimer() {
    clearTimeout(restTimerId);
}
// The skip rest timer is used to check if the user enters another tooltip target
// in a certain period of time, in which case, we would skip the rest timer and open
// the tooltip instantly.
var skipRestTimerId;
function startSkipRestTimer(transition) {
    clearTimeout(skipRestTimerId);
    skipRestTimerId = window.setTimeout(function () { return transition('skipRestTimerElapsed'); }, SKIP_REST_THRESHOLD_DURATION);
}
function clearSkipRestTimer() {
    clearTimeout(skipRestTimerId);
}

var tooltipStateMachine = createStateMachine(tooltipStateChart, {
    debug: false,
    warnOnUnknownTransitions: false,
});
var Tooltip = React.forwardRef(function (props, forwardedRef) {
    var children = props.children, label = props.label, 
    // we default `ariaLabel` to the `label` to simplify the implementation later on
    // as we then don't need to differentiate whether or not we have an `ariaLabel`
    // we instead always render it inside a `VisuallyHidden`
    _a = props.ariaLabel, 
    // we default `ariaLabel` to the `label` to simplify the implementation later on
    // as we then don't need to differentiate whether or not we have an `ariaLabel`
    // we instead always render it inside a `VisuallyHidden`
    ariaLabel = _a === void 0 ? label : _a, isOpenProp = props.isOpen, onOpenChange = props.onOpenChange, _b = props.side, side = _b === void 0 ? 'bottom' : _b, _c = props.sideOffset, sideOffset = _c === void 0 ? -5 : _c, _d = props.align, align = _d === void 0 ? 'start' : _d, _e = props.alignOffset, alignOffset = _e === void 0 ? 0 : _e, _f = props.arrowOffset, arrowOffset = _f === void 0 ? 10 : _f, _g = props.noArrow, noArrow = _g === void 0 ? false : _g, _h = props.collisionTolerance, collisionTolerance = _h === void 0 ? 0 : _h, styleConfig = props.styleConfig, contentProps = __rest(props, ["children", "label", "ariaLabel", "isOpen", "onOpenChange", "side", "sideOffset", "align", "alignOffset", "arrowOffset", "noArrow", "collisionTolerance", "styleConfig"]);
    var debugContext = useDebugContext();
    var variantNames = getVariantNamesFromStyleConfig(styleConfig);
    var variantsMap = makeVariantsMap(props, variantNames);
    var contentStyles = getPartStyles('content', styleConfig, variantsMap);
    var arrowStyles = getPartStyles('arrow', styleConfig, variantsMap);
    var id = "tooltip-" + useId();
    // send transition if the component unmounts
    React.useEffect(function () {
        return function () {
            tooltipStateMachine.transition('unmounted', { id: id });
        };
    }, [id]);
    // if we're controlling the component
    // put the state machine in the appropriate state
    React.useEffect(function () {
        if (isOpenProp === true) {
            tooltipStateMachine.transition('mouseEntered', { id: id });
        }
    }, [id, isOpenProp]);
    var _j = useControlledState({
        prop: isOpenProp,
        onChange: onOpenChange,
    }), _isOpen = _j[0], setIsOpen = _j[1];
    var isOpen = Boolean(_isOpen);
    var targetRef = React.useRef(null);
    var targetRect = useRect({
        refToObserve: targetRef,
        isObserving: isOpen,
        shouldResetWhenNotObserving: true,
    });
    var targetLeft = targetRect === null || targetRect === void 0 ? void 0 : targetRect.left;
    var previousTargetLeft = usePrevious(targetLeft);
    var targetTop = targetRect === null || targetRect === void 0 ? void 0 : targetRect.top;
    var previousTargetTop = usePrevious(targetTop);
    var popperRef = React.useRef(null);
    var popperSize = useSize({ refToObserve: popperRef, isObserving: isOpen });
    var arrowRef = React.useRef(null);
    var arrowSize = useSize({ refToObserve: arrowRef, isObserving: isOpen });
    var _k = getPlacementData({
        popperSize: popperSize,
        targetRect: targetRect,
        arrowSize: arrowSize,
        arrowOffset: arrowOffset,
        side: side,
        sideOffset: sideOffset,
        align: align,
        alignOffset: alignOffset,
        collisionTolerance: collisionTolerance,
        shouldAvoidCollisions: !debugContext.disableCollisionChecking,
    }), popperStyles = _k.popperStyles, arrowPlacementStyles = _k.arrowStyles;
    React.useEffect(function () {
        var unsubscribe = tooltipStateMachine.subscribe(function (state, context) {
            if (state === 'OPEN' && context.id === id) {
                setIsOpen(true);
            }
            else {
                setIsOpen(false);
            }
        });
        return unsubscribe;
    }, [id, setIsOpen]);
    React.useEffect(function () {
        // checking if the user has scrolled…
        var hasTargetMoved = (previousTargetLeft !== undefined && previousTargetLeft !== targetLeft) ||
            (previousTargetTop !== undefined && previousTargetTop !== targetTop);
        if (isOpen && hasTargetMoved) {
            tooltipStateMachine.transition('targetMoved', { id: id });
        }
    }, [id, isOpen, previousTargetLeft, previousTargetTop, targetLeft, targetTop]);
    var child = React.Children.only(children);
    var _l = child.props, onMouseEnter = _l.onMouseEnter, onMouseMove = _l.onMouseMove, onMouseLeave = _l.onMouseLeave, onFocus = _l.onFocus, onBlur = _l.onBlur, onMouseDown = _l.onMouseDown, onKeyDown = _l.onKeyDown;
    return (React.createElement(React.Fragment, null,
        React.cloneElement(child, {
            ref: useComposedRefs(child.ref, targetRef),
            'aria-describedby': id,
            onMouseEnter: composeEventHandlers(onMouseEnter, function () { return tooltipStateMachine.transition('mouseEntered', { id: id }); }),
            onMouseMove: composeEventHandlers(onMouseMove, function () { return tooltipStateMachine.transition('mouseMoved', { id: id }); }),
            onMouseLeave: composeEventHandlers(onMouseLeave, function () {
                var context = tooltipStateMachine.getContext();
                if (context.id === id) {
                    tooltipStateMachine.transition('mouseLeft', { id: id });
                }
            }),
            onFocus: composeEventHandlers(onFocus, function () { return tooltipStateMachine.transition('focused', { id: id }); }),
            onBlur: composeEventHandlers(onBlur, function () {
                var context = tooltipStateMachine.getContext();
                if (context.id === id) {
                    tooltipStateMachine.transition('blurred', { id: id });
                }
            }),
            onMouseDown: composeEventHandlers(onMouseDown, function () { return tooltipStateMachine.transition('activated', { id: id }); }),
            onKeyDown: composeEventHandlers(onKeyDown, function (event) {
                if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {
                    tooltipStateMachine.transition('activated', { id: id });
                }
            }),
        }),
        isOpen ? (React.createElement(Portal, null,
            React.createElement("div", { style: __assign(__assign({}, popperStyles), { zIndex: 99999, pointerEvents: 'none' }) },
                React.createElement("div", { ref: popperRef },
                    React.createElement(ContentPart$2, __assign({ ref: forwardedRef }, contentProps, { contentStyles: contentStyles }), label)),
                React.createElement(VisuallyHidden, { id: id, role: "tooltip" }, ariaLabel),
                noArrow ? null : (React.createElement("div", { style: arrowPlacementStyles },
                    React.createElement(Arrow, { ref: arrowRef, 
                        // at this point `arrowStyles` already has the variants applied
                        // so we can just create styleConfig with base styles on the fly
                        styleConfig: {
                            base: { arrow: arrowStyles },
                        } })))))) : null));
});
Tooltip.displayName = 'Tooltip';
var ContentPart$2 = styled('div').attrs({ 'data-part-id': 'content' })(
// reset styles
cssReset('div'), 
// functional styles
{
    display: 'inline-flex',
    alignItems: 'center',
}, 
// apply style config
function (_a) {
    var _b = _a.contentStyles, contentStyles = _b === void 0 ? {} : _b;
    return contentStyles.normal;
}, 
// add system support
boxSystemProps);
ContentPart$2.displayName = 'ContentPart';

exports.AccessibleIcon = AccessibleIcon;
exports.Alert = Alert;
exports.Arrow = Arrow;
exports.AspectRatio = AspectRatio;
exports.Avatar = Avatar;
exports.Badge = Badge;
exports.Blockquote = Blockquote;
exports.Box = Box;
exports.Button = Button;
exports.Card = Card;
exports.CardLink = CardLink;
exports.Checkbox = Checkbox;
exports.Code = Code;
exports.Container = Container;
exports.DebugContextProvider = DebugContextProvider;
exports.Dialog = Dialog;
exports.Divider = Divider;
exports.DropdownMenu = DropdownMenu;
exports.Flex = Flex;
exports.Grid = Grid;
exports.Header = Header;
exports.Image = Image$1;
exports.Input = Input$1;
exports.Link = Link;
exports.Lock = Lock;
exports.Menu = Menu;
exports.MenuItem = MenuItem;
exports.MenuItemCheckbox = MenuItemCheckbox;
exports.MenuItemLabel = MenuItemLabel;
exports.MenuItemRadio = MenuItemRadio;
exports.MenuItemRadioGroup = MenuItemRadioGroup;
exports.MenuItemSeparator = MenuItemSeparator;
exports.Option = Option$1;
exports.OptionGroup = OptionGroup$1;
exports.Overlay = Overlay;
exports.Pipe = Pipe;
exports.Popover = Popover;
exports.Portal = Portal;
exports.Radio = Radio;
exports.RightClickMenu = RightClickMenu;
exports.RightClickable = RightClickable;
exports.Select = Select;
exports.SelectWithCustomMenu = SelectWithCustomMenu;
exports.SelectWithNativeMenu = SelectWithNativeMenu;
exports.Sheet = Sheet;
exports.Slider = Slider;
exports.SliderInnerTrack = InnerTrackPart;
exports.SliderInput = InputPart$1;
exports.SliderTrack = TrackPart;
exports.Switch = Switch;
exports.SwitchContained = SwitchContained;
exports.SwitchSlider = SwitchSlider;
exports.Tab = Tab;
exports.TabList = TabList;
exports.TabPanel = TabPanel;
exports.Table = Table;
exports.Tabs = Tabs;
exports.Tbody = Tbody;
exports.Td = Td;
exports.Text = Text;
exports.Textarea = Textarea;
exports.Tfoot = Tfoot;
exports.Th = Th;
exports.Thead = Thead;
exports.ToggleButton = ToggleButton;
exports.Tooltip = Tooltip;
exports.Tr = Tr;
exports.VisuallyHidden = VisuallyHidden;
exports.useDropdownMenu = useDropdownMenu;
